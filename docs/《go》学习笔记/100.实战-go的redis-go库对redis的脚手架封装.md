---
title: go的redis-go库对redis的脚手架封装
date: 2022-05-18 16:19:34
permalink: /pages/go100/
categories:
  - 《go》学习笔记
tags:
  - go
---






## 1、依赖库



```go
go get github.com/go-redis/redis/v8
```

[官方库地址](https://github.com/go-redis/redis)

## 2、初始化redis连接



```go
package main

import (
	"context"
	"github.com/shenyisyn/goft-redis/gedis"
	"log"
)

func main()  {

	ctx:=context.Background()
    // 查找K
	ret:=gedis.Redis().Get(ctx,"name")
    
	v,err:=ret.Result()
	if err!=nil{
		log.Fatal(err)
	}
	log.Println(v)
}
```

```go
package gedis

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
	"log"
	"sync"
	"time"
)

var redisClient *redis.Client

// 初始化
var redisClient_Once sync.Once

func Redis() *redis.Client {
	redisClient_Once.Do(func() {
		redisClient = redis.NewClient(&redis.Options{
			Network:  "tcp",
			Addr:     "127.0.0.1:6379",
			Password: "", //密码
			DB:       0,  // redis数据库

			//连接池容量及闲置连接数量
			PoolSize:     15, // 连接池数量
			MinIdleConns: 10, //好比最小连接数
			//超时
			DialTimeout:  5 * time.Second, //连接建立超时时间
			ReadTimeout:  3 * time.Second, //读超时，默认3秒， -1表示取消读超时
			WriteTimeout: 3 * time.Second, //写超时，默认等于读超时
			PoolTimeout:  4 * time.Second, //当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。

			//闲置连接检查包括IdleTimeout，MaxConnAge
			IdleCheckFrequency: 60 * time.Second, //闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。
			IdleTimeout:        5 * time.Minute,  //闲置超时
			MaxConnAge:         0 * time.Second,  //连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接

			//命令执行失败时的重试策略
			MaxRetries:      0,                      // 命令执行失败时，最多重试多少次，默认为0即不重试
			MinRetryBackoff: 8 * time.Millisecond,   //每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔
			MaxRetryBackoff: 512 * time.Millisecond, //每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔

		})
		pong, err := redisClient.Ping(context.Background()).Result()
		if err != nil {
			log.Fatal(fmt.Errorf("connect error:%s", err))
		}
		log.Println(pong)
	})
	return redisClient
}

```

```sh
docker run -p 6379:6379 --name redis -v /mydata/redis/redis.conf:/etc/redis/redis.conf -v /mydata/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes #启动测试redis
```

## 3、封装方法和错误信息



初始化无变动

```go
package gedis

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
	"log"
	"sync"
	"time"
)

var redisClient *redis.Client

// 初始化
var redisClient_Once sync.Once

func Redis() *redis.Client {
	redisClient_Once.Do(func() {
		redisClient = redis.NewClient(&redis.Options{
			Network:  "tcp",
			Addr:     "10.165.25.24:6379",
			Password: "", //密码
			DB:       0,  // redis数据库

			//连接池容量及闲置连接数量
			PoolSize:     15, // 连接池数量
			MinIdleConns: 10, //好比最小连接数
			//超时
			DialTimeout:  5 * time.Second, //连接建立超时时间
			ReadTimeout:  3 * time.Second, //读超时，默认3秒， -1表示取消读超时
			WriteTimeout: 3 * time.Second, //写超时，默认等于读超时
			PoolTimeout:  4 * time.Second, //当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。

			//闲置连接检查包括IdleTimeout，MaxConnAge
			IdleCheckFrequency: 60 * time.Second, //闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。
			IdleTimeout:        5 * time.Minute,  //闲置超时
			MaxConnAge:         0 * time.Second,  //连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接

			//命令执行失败时的重试策略
			MaxRetries:      0,                      // 命令执行失败时，最多重试多少次，默认为0即不重试
			MinRetryBackoff: 8 * time.Millisecond,   //每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔
			MaxRetryBackoff: 512 * time.Millisecond, //每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔

		})
		pong, err := redisClient.Ping(context.Background()).Result()
		if err != nil {
			log.Fatal(fmt.Errorf("connect error:%s", err))
		}
		log.Println(pong)
	})
	return redisClient
}

```

```go
package gedis

import (
	"context"
)

type StringOperation struct {
	ctx context.Context
}

func NewStringOperation() *StringOperation {
	return &StringOperation{ctx: context.Background()}
}

func (this *StringOperation) Set() {

}

func (this *StringOperation) Get(key string) *StringResult {
	return NewStringResult(Redis().Get(this.ctx, key).Result())

}

```

```go
package gedis
// 结构体
type StringResult struct {
	Result string
	Err    error
}
// 构造函数
func NewStringResult(result string, err error) *StringResult {
	return &StringResult{Result: result, Err: err}
}

// 处理结果过滤nil
func (this *StringResult) Unwrap() string {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
//处理结果赋予默认值
func (this *StringResult) Unwrap_or(str string) string {
	if this.Err != nil {
		return str
	}
	return this.Result
}
```



```go
package main

import (
	"fmt"
	"github.com/shenyisyn/goft-redis/gedis"
)

func main() {
	//对get方法的封装
	fmt.Println(gedis.NewStringOperation().Get("name2").Unwrap_or("def"))
}

```

## 4、获取多值、迭代器的初步实现

```go
package gedis

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
	"log"
	"sync"
	"time"
)

var redisClient *redis.Client

// 初始化
var redisClient_Once sync.Once

func Redis() *redis.Client {
	redisClient_Once.Do(func() {
		redisClient = redis.NewClient(&redis.Options{
			Network:  "tcp",
			Addr:     "10.165.25.24:6379",
			Password: "", //密码
			DB:       0,  // redis数据库

			//连接池容量及闲置连接数量
			PoolSize:     15, // 连接池数量
			MinIdleConns: 10, //好比最小连接数
			//超时
			DialTimeout:  5 * time.Second, //连接建立超时时间
			ReadTimeout:  3 * time.Second, //读超时，默认3秒， -1表示取消读超时
			WriteTimeout: 3 * time.Second, //写超时，默认等于读超时
			PoolTimeout:  4 * time.Second, //当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。

			//闲置连接检查包括IdleTimeout，MaxConnAge
			IdleCheckFrequency: 60 * time.Second, //闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。
			IdleTimeout:        5 * time.Minute,  //闲置超时
			MaxConnAge:         0 * time.Second,  //连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接

			//命令执行失败时的重试策略
			MaxRetries:      0,                      // 命令执行失败时，最多重试多少次，默认为0即不重试
			MinRetryBackoff: 8 * time.Millisecond,   //每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔
			MaxRetryBackoff: 512 * time.Millisecond, //每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔

		})
		pong, err := redisClient.Ping(context.Background()).Result()
		if err != nil {
			log.Fatal(fmt.Errorf("connect error:%s", err))
		}
		log.Println(pong)
	})
	return redisClient
}

```

```go
package gedis

// 迭代器
type Iterator struct {
	data  []interface{}
	index int
}

func NewIterator(data []interface{}) *Iterator {
	return &Iterator{data: data}
}

func (this *Iterator) HasNext() bool {
	// 检测切片是否为最后一个
	if this.data == nil || len(this.data) == 0 {
		return false
	}
	return this.index < len(this.data)
}
//查找index数据
func (this *Iterator) Netx() (ret interface{}) {
	ret = this.data[this.index]
	this.index = this.index + 1
	return

}

```

```go
package gedis

//新增切片多个参数返回
type SliceResult struct {
	Result []interface{}
	Err    error
}

func NewSliceResult(result []interface{}, err error) *SliceResult {
	return &SliceResult{Result: result, Err: err}
}
func (this *SliceResult) Unwrap() []interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *SliceResult) Unwrap_or(v []interface{}) []interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}
func (this *SliceResult) Iter() *Iterator {

	return NewIterator(this.Result)
}

```



```go
package gedis

import (
	"context"
)

type StringOperation struct {
	ctx context.Context
}

func NewStringOperation() *StringOperation {
	return &StringOperation{ctx: context.Background()}
}

func (this *StringOperation) Set() {

}

func (this *StringOperation) Get(key string) *StringResult {
	return NewStringResult(Redis().Get(this.ctx, key).Result())

}
//新增多个KEY获取的方法
func (this *StringOperation) MGet(keys ...string) *SliceResult {
	return NewSliceResult(Redis().MGet(this.ctx, keys...).Result())

}

```

```go
package gedis
//无需改动单个结构体生成
type StringResult struct {
	Result string
	Err    error
}

func NewStringResult(result string, err error) *StringResult {
	return &StringResult{Result: result, Err: err}
}
func (this *StringResult) Unwrap() string {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *StringResult) Unwrap_or(str string) string {
	if this.Err != nil {
		return str
	}
	return this.Result
}

```



```go
package main

import (
	"fmt"
	"github.com/shenyisyn/goft-redis/gedis"
)

func main() {

	iter := (gedis.NewStringOperation().MGet("name", "age", "test").Iter())
	for iter.HasNext() {
		fmt.Println(iter.Netx())
	}

}

```

## 5、对有生命周期的SET的命令的封装

初始化

```go
package gedis

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
	"log"
	"sync"
	"time"
)

var redisClient *redis.Client

// 初始化
var redisClient_Once sync.Once

func Redis() *redis.Client {
	redisClient_Once.Do(func() {
		redisClient = redis.NewClient(&redis.Options{
			Network:  "tcp",
			Addr:     "10.165.25.24:6379",
			Password: "", //密码
			DB:       0,  // redis数据库

			//连接池容量及闲置连接数量
			PoolSize:     15, // 连接池数量
			MinIdleConns: 10, //好比最小连接数
			//超时
			DialTimeout:  5 * time.Second, //连接建立超时时间
			ReadTimeout:  3 * time.Second, //读超时，默认3秒， -1表示取消读超时
			WriteTimeout: 3 * time.Second, //写超时，默认等于读超时
			PoolTimeout:  4 * time.Second, //当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。

			//闲置连接检查包括IdleTimeout，MaxConnAge
			IdleCheckFrequency: 60 * time.Second, //闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。
			IdleTimeout:        5 * time.Minute,  //闲置超时
			MaxConnAge:         0 * time.Second,  //连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接

			//命令执行失败时的重试策略
			MaxRetries:      0,                      // 命令执行失败时，最多重试多少次，默认为0即不重试
			MinRetryBackoff: 8 * time.Millisecond,   //每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔
			MaxRetryBackoff: 512 * time.Millisecond, //每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔

		})
		pong, err := redisClient.Ping(context.Background()).Result()
		if err != nil {
			log.Fatal(fmt.Errorf("connect error:%s", err))
		}
		log.Println(pong)
	})
	return redisClient
}

```

迭代器无需变更

```go
package gedis

type Iterator struct {
	data  []interface{}
	index int
}

func NewIterator(data []interface{}) *Iterator {
	return &Iterator{data: data}
}

func (this *Iterator) HasNext() bool {
	// 检测切片是否为最后一个
	if this.data == nil || len(this.data) == 0 {
		return false
	}
	return this.index < len(this.data)
}
func (this *Iterator) Netx() (ret interface{}) {
	ret = this.data[this.index]
	this.index = this.index + 1
	return

}

```

```go
package gedis

import (
	"time"
)

const (
	ATTR_EXPRIRE = "expr"
)
// 新增过期结构体
type OperationAttr struct {
	Name  string
	Value interface{}
}
type OperationAttrs []*OperationAttr

func (this OperationAttrs) Find(name string) interface{} {
	for _, attr := range this {
		if attr.Name == name {
			return attr.Value
		}

	}
	return nil
}

func WithExpire(t time.Duration) *OperationAttr {
	return &OperationAttr{
		Name:  ATTR_EXPRIRE,
		Value: t,
	}

}

```



```go
package gedis

type SliceResult struct {
	Result []interface{}
	Err    error
}

func NewSliceResult(result []interface{}, err error) *SliceResult {
	return &SliceResult{Result: result, Err: err}
}
func (this *SliceResult) Unwrap() []interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *SliceResult) Unwrap_or(v []interface{}) []interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}
func (this *SliceResult) Iter() *Iterator {

	return NewIterator(this.Result)
}

```



```go
package gedis

import (
	"context"
	"time"
)

type StringOperation struct {
	ctx context.Context
}

func NewStringOperation() *StringOperation {
	return &StringOperation{ctx: context.Background()}
}
// 设置传入值和时间生命周期
func (this *StringOperation) Set(key string, value interface{}, attrs ...*OperationAttr) *StringResult {
    // 转换类型本来是指针，调用find方法找到常量设置的生命周期
	exp := OperationAttrs(attrs).Find(ATTR_EXPRIRE)
    // 如果取不到值则给予默认值0
	if exp == nil {
		exp = time.Second * 0
	}
    // 返回字符结果 
	return NewStringResult(Redis().Set(this.ctx, key, value, exp.(time.Duration)).Result())
}

func (this *StringOperation) Get(key string) *StringResult {
	return NewStringResult(Redis().Get(this.ctx, key).Result())

}
func (this *StringOperation) MGet(keys ...string) *SliceResult {
	return NewSliceResult(Redis().MGet(this.ctx, keys...).Result())

}

```

```go
//结果无需改变
package gedis

type StringResult struct {
	Result string
	Err    error
}

func NewStringResult(result string, err error) *StringResult {
	return &StringResult{Result: result, Err: err}
}
func (this *StringResult) Unwrap() string {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *StringResult) Unwrap_or(str string) string {
	if this.Err != nil {
		return str
	}
	return this.Result
}

```



```go
package main

import (
	"fmt"
	"github.com/shenyisyn/goft-redis/gedis"
	"time"
)

func main() {

	iter := (gedis.NewStringOperation().MGet("name", "age", "test").Iter())
	for iter.HasNext() {
		fmt.Println(iter.Netx())
	}
	fmt.Println(gedis.NewStringOperation().Set("name", "胸毛", gedis.WithExpire(time.Second*29)))

}

```

## 6、redis的SetNx封装

初始化

```go
package gedis

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
	"log"
	"sync"
	"time"
)

var redisClient *redis.Client

// 初始化
var redisClient_Once sync.Once

func Redis() *redis.Client {
	redisClient_Once.Do(func() {
		redisClient = redis.NewClient(&redis.Options{
			Network:  "tcp",
			Addr:     "10.165.25.24:6379",
			Password: "", //密码
			DB:       0,  // redis数据库

			//连接池容量及闲置连接数量
			PoolSize:     15, // 连接池数量
			MinIdleConns: 10, //好比最小连接数
			//超时
			DialTimeout:  5 * time.Second, //连接建立超时时间
			ReadTimeout:  3 * time.Second, //读超时，默认3秒， -1表示取消读超时
			WriteTimeout: 3 * time.Second, //写超时，默认等于读超时
			PoolTimeout:  4 * time.Second, //当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。

			//闲置连接检查包括IdleTimeout，MaxConnAge
			IdleCheckFrequency: 60 * time.Second, //闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。
			IdleTimeout:        5 * time.Minute,  //闲置超时
			MaxConnAge:         0 * time.Second,  //连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接

			//命令执行失败时的重试策略
			MaxRetries:      0,                      // 命令执行失败时，最多重试多少次，默认为0即不重试
			MinRetryBackoff: 8 * time.Millisecond,   //每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔
			MaxRetryBackoff: 512 * time.Millisecond, //每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔

		})
		pong, err := redisClient.Ping(context.Background()).Result()
		if err != nil {
			log.Fatal(fmt.Errorf("connect error:%s", err))
		}
		log.Println(pong)
	})
	return redisClient
}

```

新增对`interfaceResult`

```go
package gedis

type InterfaceResult struct {
	Result interface{}
	Err    error
}

func NewInterfaceResult(result interface{}, err error) *InterfaceResult {
	return &InterfaceResult{Result: result, Err: err}
}
func (this *InterfaceResult) Unwrap() interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *InterfaceResult) Unwrap_Or(v interface{}) interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}

```

迭代不动

```go
package gedis

type Iterator struct {
	data  []interface{}
	index int
}

func NewIterator(data []interface{}) *Iterator {
	return &Iterator{data: data}
}

func (this *Iterator) HasNext() bool {
	// 检测切片是否为最后一个
	if this.data == nil || len(this.data) == 0 {
		return false
	}
	return this.index < len(this.data)
}
func (this *Iterator) Netx() (ret interface{}) {
	ret = this.data[this.index]
	this.index = this.index + 1
	return

}

```



```go
package gedis

import (
	"fmt"
	"time"
)

type empty struct{}

const (
	ATTR_EXPIRE = "expr" //过期时间
	ATTR_NX     = "nx"   // setnx
)

//属性
type OperationAttr struct {
	Name  string
	Value interface{}
}
type OperationAttrs []*OperationAttr
//修改此处对interface的引用
func (this OperationAttrs) Find(name string) *InterfaceResult {
	for _, attr := range this {
		if attr.Name == name {
			return NewInterfaceResult(attr.Value, nil)
		}
	}
	return NewInterfaceResult(nil, fmt.Errorf("OperationAttrs found error:%s", name))
}
func WithExpire(t time.Duration) *OperationAttr {
	return &OperationAttr{Name: ATTR_EXPIRE, Value: t}
}
func WithNX() *OperationAttr {
	return &OperationAttr{Name: ATTR_NX, Value: empty{}}
}

```

切片

```go
package gedis

type SliceResult struct {
	Result []interface{}
	Err    error
}

func NewSliceResult(result []interface{}, err error) *SliceResult {
	return &SliceResult{Result: result, Err: err}
}
func (this *SliceResult) Unwrap() []interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *SliceResult) Unwrap_or(v []interface{}) []interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}
func (this *SliceResult) Iter() *Iterator {

	return NewIterator(this.Result)
}

```



```go
package gedis

type StringResult struct {
	Result string
	Err    error
}

func NewStringResult(result string, err error) *StringResult {
	return &StringResult{Result: result, Err: err}
}
func (this *StringResult) Unwrap() string {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *StringResult) Unwrap_or(str string) string {
	if this.Err != nil {
		return str
	}
	return this.Result
}

```



```go
package gedis

import (
	"context"
	"time"
)

//专门处理string类型的操作
type StringOperation struct {
	ctx context.Context
}

func NewStringOperation() *StringOperation {
	return &StringOperation{ctx: context.Background()}
}
//修改此处对SetNx的追加
func (this *StringOperation) Set(key string, value interface{}, attrs ...*OperationAttr) *InterfaceResult {
	exp := OperationAttrs(attrs).Find(ATTR_EXPIRE)

	nx := OperationAttrs(attrs).Find(ATTR_NX).Unwrap_Or(nil)
	if nx != nil {
		return NewInterfaceResult(Redis().SetNX(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())
	}
	return NewInterfaceResult(Redis().Set(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())

}

func (this *StringOperation) Get(key string) *StringResult {
	return NewStringResult(Redis().Get(this.ctx, key).Result())
}
func (this *StringOperation) MGet(keys ...string) *SliceResult {
	return NewSliceResult(Redis().MGet(this.ctx, keys...).Result())
}

```



```go
package main

import (
	"fmt"
	"github.com/shenyisyn/goft-redis/gedis"
	"time"
)

func main() {
	/*
		iter := (gedis.NewStringOperation().MGet("name", "age", "test").Iter())
		for iter.HasNext() {
			fmt.Println(iter.Netx())
		}
	*/
	fmt.Println(gedis.NewStringOperation().Set("name", "胸毛", gedis.WithExpire(time.Second*29), gedis.WithNX()))

}

```

## 7、redis的SetXx的封装

与6步骤类似主要是对方法的封装

```go
package gedis

import (
	"context"
	"time"
)

//专门处理string类型的操作
type StringOperation struct {
	ctx context.Context
}

func NewStringOperation() *StringOperation {
	return &StringOperation{ctx: context.Background()}
}

func (this *StringOperation) Set(key string, value interface{}, attrs ...*OperationAttr) *InterfaceResult {
	exp := OperationAttrs(attrs).Find(ATTR_EXPIRE)

	nx := OperationAttrs(attrs).Find(ATTR_NX).Unwrap_Or(nil)
    //判断setxx的执行
	xx := OperationAttrs(attrs).Find(ATTR_XX).Unwrap_Or(nil)
	if nx != nil {
		return NewInterfaceResult(Redis().SetNX(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())
	}
	if xx != nil {
		return NewInterfaceResult(Redis().SetXX(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())
	}
	return NewInterfaceResult(Redis().Set(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())

}

func (this *StringOperation) Get(key string) *StringResult {
	return NewStringResult(Redis().Get(this.ctx, key).Result())
}
func (this *StringOperation) MGet(keys ...string) *SliceResult {
	return NewSliceResult(Redis().MGet(this.ctx, keys...).Result())
}

```

```go
package gedis

import (
	"fmt"
	"time"
)

type empty struct{}

const (
	ATTR_EXPIRE = "expr" //过期时间
	ATTR_NX     = "nx"   // setnx
	ATTR_XX     = "xx"
)

//属性
type OperationAttr struct {
	Name  string
	Value interface{}
}
type OperationAttrs []*OperationAttr

func (this OperationAttrs) Find(name string) *InterfaceResult {
	for _, attr := range this {
		if attr.Name == name {
			return NewInterfaceResult(attr.Value, nil)
		}
	}
	return NewInterfaceResult(nil, fmt.Errorf("OperationAttrs found error:%s", name))
}
func WithExpire(t time.Duration) *OperationAttr {
	return &OperationAttr{Name: ATTR_EXPIRE, Value: t}
}
func WithNX() *OperationAttr {
	return &OperationAttr{Name: ATTR_NX, Value: empty{}}
}

```

## 8、对数据库缓存组件的封装

初始化连接

```go
package gedis

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
	"log"
	"sync"
	"time"
)

var redisClient *redis.Client

// 初始化
var redisClient_Once sync.Once

func Redis() *redis.Client {
	redisClient_Once.Do(func() {
		redisClient = redis.NewClient(&redis.Options{
			Network:  "tcp",
			Addr:     "10.165.25.24:6379",
			Password: "", //密码
			DB:       0,  // redis数据库

			//连接池容量及闲置连接数量
			PoolSize:     15, // 连接池数量
			MinIdleConns: 10, //好比最小连接数
			//超时
			DialTimeout:  5 * time.Second, //连接建立超时时间
			ReadTimeout:  3 * time.Second, //读超时，默认3秒， -1表示取消读超时
			WriteTimeout: 3 * time.Second, //写超时，默认等于读超时
			PoolTimeout:  4 * time.Second, //当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。

			//闲置连接检查包括IdleTimeout，MaxConnAge
			IdleCheckFrequency: 60 * time.Second, //闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。
			IdleTimeout:        5 * time.Minute,  //闲置超时
			MaxConnAge:         0 * time.Second,  //连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接

			//命令执行失败时的重试策略
			MaxRetries:      0,                      // 命令执行失败时，最多重试多少次，默认为0即不重试
			MinRetryBackoff: 8 * time.Millisecond,   //每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔
			MaxRetryBackoff: 512 * time.Millisecond, //每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔

		})
		pong, err := redisClient.Ping(context.Background()).Result()
		if err != nil {
			log.Fatal(fmt.Errorf("connect error:%s", err))
		}
		log.Println(pong)
	})
	return redisClient
}

```

```go
package gedis

type InterfaceResult struct {
	Result interface{}
	Err    error
}

func NewInterfaceResult(result interface{}, err error) *InterfaceResult {
	return &InterfaceResult{Result: result, Err: err}
}
func (this *InterfaceResult) Unwrap() interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *InterfaceResult) Unwrap_Or(v interface{}) interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}

```

```go
package gedis

type Iterator struct {
	data  []interface{}
	index int
}

func NewIterator(data []interface{}) *Iterator {
	return &Iterator{data: data}
}

func (this *Iterator) HasNext() bool {
	// 检测切片是否为最后一个
	if this.data == nil || len(this.data) == 0 {
		return false
	}
	return this.index < len(this.data)
}
func (this *Iterator) Netx() (ret interface{}) {
	ret = this.data[this.index]
	this.index = this.index + 1
	return

}

```

```go
package gedis

import (
	"fmt"
	"time"
)

type empty struct{}

const (
	ATTR_EXPIRE = "expr" //过期时间
	ATTR_NX     = "nx"   // setnx
	ATTR_XX     = "xx"
)

//属性
type OperationAttr struct {
	Name  string
	Value interface{}
}
type OperationAttrs []*OperationAttr

func (this OperationAttrs) Find(name string) *InterfaceResult {
	for _, attr := range this {
		if attr.Name == name {
			return NewInterfaceResult(attr.Value, nil)
		}
	}
	return NewInterfaceResult(nil, fmt.Errorf("OperationAttrs found error:%s", name))
}
func WithExpire(t time.Duration) *OperationAttr {
	return &OperationAttr{Name: ATTR_EXPIRE, Value: t}
}
func WithNX() *OperationAttr {
	return &OperationAttr{Name: ATTR_NX, Value: empty{}}
}

```



```go
package gedis

type SliceResult struct {
	Result []interface{}
	Err    error
}

func NewSliceResult(result []interface{}, err error) *SliceResult {
	return &SliceResult{Result: result, Err: err}
}
func (this *SliceResult) Unwrap() []interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *SliceResult) Unwrap_or(v []interface{}) []interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}
func (this *SliceResult) Iter() *Iterator {

	return NewIterator(this.Result)
}

```

主体方法

```go
package gedis

import (
	"context"
	"time"
)

//专门处理string类型的操作
type StringOperation struct {
	ctx context.Context
}

func NewStringOperation() *StringOperation {
	return &StringOperation{ctx: context.Background()}
}

func (this *StringOperation) Set(key string, value interface{}, attrs ...*OperationAttr) *InterfaceResult {
	exp := OperationAttrs(attrs).Find(ATTR_EXPIRE)

	nx := OperationAttrs(attrs).Find(ATTR_NX).Unwrap_Or(nil)
	xx := OperationAttrs(attrs).Find(ATTR_XX).Unwrap_Or(nil)
	if nx != nil {
		return NewInterfaceResult(Redis().SetNX(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())
	}
	if xx != nil {
		return NewInterfaceResult(Redis().SetXX(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())
	}
	return NewInterfaceResult(Redis().Set(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())

}

func (this *StringOperation) Get(key string) *StringResult {
	return NewStringResult(Redis().Get(this.ctx, key).Result())
}
func (this *StringOperation) MGet(keys ...string) *SliceResult {
	return NewSliceResult(Redis().MGet(this.ctx, keys...).Result())
}

```



```go
package gedis

type StringResult struct {
	Result string
	Err    error
}

func NewStringResult(result string, err error) *StringResult {
	return &StringResult{Result: result, Err: err}
}
func (this *StringResult) Unwrap() string {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *StringResult) Unwrap_or(str string) string {
	if this.Err != nil {
		return str
	}
	return this.Result
}
// 添加方法，如果报错执行函数进行返回
func (this *StringResult) Unwrap_Or_Else(f func() string) string {
    //err不为nil执行函数
	if this.Err != nil {
		return f()
	}
	return this.Result
}

```



```go
package gedis

import "time"

type DBGettFunc func() string

type SimpeCache struct {
	Operation *StringOperation
	Exprie    time.Duration
	DBGetter  DBGettFunc
}

func NewSimpeCache(operation *StringOperation, exprie time.Duration) *SimpeCache {
	return &SimpeCache{Operation: operation, Exprie: exprie}
}

func (this *SimpeCache) SetCache(key string, value interface{}) {
	this.Operation.Set(key, value, WithExpire(this.Exprie)).Unwrap()
}
// 获取缓存
func (this *SimpeCache) GetCache(key string) (ret interface{}) {
	ret = this.Operation.Get(key).Unwrap_Or_Else(this.DBGetter)
    //调用get 如果失败就执行传入的数据库调用函数
	this.SetCache(key, ret)
    // 将数据库参数的存入rdis，提供下次的get
	return
}

```



```go
package main

import (
	"fmt"
	"github.com/shenyisyn/goft-redis/gedis"
	"log"
	"time"
)

func main() {
    //初始化
	newCache := gedis.NewSimpeCache(gedis.NewStringOperation(), time.Second*10)
    // 模拟数据库
	newCache.DBGetter = func() string {
		log.Println("get from db")
		return "data by id=123"
	}
	fmt.Println(newCache.GetCache("news123"))
	fmt.Println(newCache.GetCache("news123"))

}

```

## 9、对数据库缓存组件的封装2

主要对gorm的引用测试

gorm官方地址

[gorm](https://gorm.io/docs/)

依赖库下载

```
go get -u gorm.io/gorm  v1.20.0 
go get -u gorm.io/driver/mysql v1.0.0

```

```sh
docker run -p 3306:3306 --name mysql -v /usr/mydata/mysql/log:/var/log/mysql -v /usr/mydata/mysql/data:/var/lib/mysql -v /usr/mydata/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 #mysql快速
```

创建数据库

```mysql
CREATE database test;
```



```mysql
CREATE TABLE `mynews` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `newstitle` varchar(255) DEFAULT NULL,
  `views` varchar(255) DEFAULT NULL,
  `newscontent` varchar(255) DEFAULT NULL,
  `addtime` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
```



mysql的连接

初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	"log"
)

var Gorm *gorm.DB

func init() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {
	dsn := "root:123456@tcp(10.165.25.25:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```



```go
package lib

import "time"

type NewsModel struct {
	NewsID int `gorm:"column:id" json:"id"`
	NewsTitle string `gorm:"column:newstitle" json:"title"`
	NewsContent string `gorm:"column:newscontent" json:"content"`
	NewsViews int `gorm:"column:views" json:"views"`
	NewsTime time.Time `gorm:"column:addtime" json:"addtime"`
}

func NewNewsModel() *NewsModel {
	return &NewsModel{}
}
```



```go
package main

import (
	"encoding/json"
	"fmt"
	"github.com/shenyisyn/goft-redis/gedis"
	"github.com/shenyisyn/goft-redis/lib"
	"log"
	"time"
)

func main() {
	newCache := gedis.NewSimpeCache(gedis.NewStringOperation(), time.Second*10)
	newsID := 1
	newCache.DBGetter = func() string {
		log.Println("get from db")
		newsModel := lib.NewNewsModel()
		lib.Gorm.Table("mynews").Where("id=?", newsID).Find(newsModel)
		b, _ := json.Marshal(newsModel)
		return string(b)
	}
	fmt.Println(newCache.GetCache("news123"))
	fmt.Println(newCache.GetCache("news123"))

}

```

## 10、对数据库的缓存封装gin+grom3

引入gin框架

```go
go get -u github.com/gin-gonic/gin 
```



没有改变mysql的初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	"log"
)

var Gorm *gorm.DB

func init() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {
	dsn := "root:123456@tcp(10.165.25.25:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```

对数据库结果反编译的结构体

```go
package lib

import "time"

type NewsModel struct {
	NewsID int `gorm:"column:id" json:"id"`
	NewsTitle string `gorm:"column:newstitle" json:"title"`
	NewsContent string `gorm:"column:newscontent" json:"content"`
	NewsViews int `gorm:"column:views" json:"views"`
	NewsTime time.Time `gorm:"column:addtime" json:"addtime"`
}

func NewNewsModel() *NewsModel {
	return &NewsModel{}
}
```

对数据库获取值进行封装

```go
package lib

import (
	"encoding/json"
	"fmt"
	"github.com/shenyisyn/goft-redis/gedis"
)

func NewDBGetter(id string) gedis.DBGettFunc {
	fmt.Println("use DBGetter")
	return func() string {
		newsModel := NewNewsModel()
		Gorm.Table("mynews").Where("id=?", id).Find(newsModel)
		b, _ := json.Marshal(newsModel)
		return string(b)
	}

}

```



添加缓存池

```go
package lib

import (
	"github.com/shenyisyn/goft-redis/gedis"
	"sync"
	"time"
)

var NewsCachePool *sync.Pool

func init() {
	NewsCachePool = &sync.Pool{
		New: func() interface{} {
			return gedis.NewSimpeCache(gedis.NewStringOperation(), time.Second*15)
		},
	}
}
//初始化
func NewsCache() *gedis.SimpeCache {
	return NewsCachePool.Get().(*gedis.SimpeCache)
}
//释放
func ReleaseNewCache(cache *gedis.SimpeCache) {
	NewsCachePool.Put(cache)
}

```



```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/shenyisyn/goft-redis/lib"
)

func main() {
    // 添加gin框架
	r := gin.New()
	r.Handle("GET", "/news/:id", func(context *gin.Context) {
		newsCache := lib.NewsCache()
		defer lib.ReleaseNewCache(newsCache)
        //获取用户传递的参数
		newsID := context.Param("id")
		newsCache.DBGetter = lib.NewDBGetter(newsID)
		context.Header("Content-type", "application/json")
		context.String(200, newsCache.GetCache("name"+newsID).(string))

	})
	r.Run(":80")

}

```



![image-20220426191100874](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202204261912372.png)

此时的缓存在`redis`中15秒后过期

![image-20220426194559075](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202204261946893.png)







## 11、对数据库缓存JSON序列化

构造函数

```go
package lib

import "time"

type NewsModel struct {
	NewsID int `gorm:"column:id" json:"id"`
	NewsTitle string `gorm:"column:newstitle" json:"title"`
	NewsContent string `gorm:"column:newscontent" json:"content"`
	NewsViews int `gorm:"column:views" json:"views"`
	NewsTime time.Time `gorm:"column:addtime" json:"addtime"`
}

func NewNewsModel() *NewsModel {
	return &NewsModel{}
}
```



数据库的初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	"log"
)

var Gorm *gorm.DB

func init() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {
	dsn := "root:123456@tcp(10.165.25.25:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```





主要对`json`序列化

```go
package gedis

import (
	"encoding/json"
	"time"
)

const (
	// 定义json的常量
	Serilizer_JSON = "json"
)

type DBGettFunc func() interface{}

type SimpeCache struct {
	Operation *StringOperation
	Exprie    time.Duration
	DBGetter  DBGettFunc
	// 添加json序列化的类型
	Serilizer string
}

func NewSimpeCache(operation *StringOperation, exprie time.Duration, serilizer string) *SimpeCache {
	return &SimpeCache{Operation: operation, Exprie: exprie, Serilizer: serilizer}
}

func (this *SimpeCache) SetCache(key string, value interface{}) {
	this.Operation.Set(key, value, WithExpire(this.Exprie)).Unwrap()
}

func (this *SimpeCache) GetCache(key string) (ret interface{}) {
	// 判断Serilizer_JSON的方式
	if this.Serilizer == Serilizer_JSON {
		// 定义一个匿名参数 获取缓存失败，就去数据库里面取
		f := func() string {
			obj := this.DBGetter()
			b, err := json.Marshal(obj)
			if err != nil {
				return ""
			}
			return string(b)
		}
		ret = this.Operation.Get(key).Unwrap_Or_Else(f)
		this.SetCache(key, ret)
	}

	return
}

```

数据库返回

```go
package lib

import (
	"fmt"
	"github.com/shenyisyn/goft-redis/gedis"
)

func NewDBGetter(id string) gedis.DBGettFunc {
	fmt.Println("use DBGetter")
	return func() interface{} {
		newsModel := NewNewsModel()
		Gorm.Table("mynews").Where("id=?", id).Find(newsModel)
		return newsModel
	}

}

```

## 12、对数据库缓存gob的优化-全

Gob 通常用于远程方法调用参数和结果的传输，以及应用程序和机器之间的数据传输。它和 JSON 或 XML 有什么不同呢？Gob 特定的用于纯 Go 的环境中，例如两个用Go语言写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。



gin -> 获取数据 -> redis缓存 -> 序列化与反序列化





```go
package lib

import (
	"github.com/shenyisyn/goft-redis/gedis"
	"sync"
	"time"
)

var NewsCachePool *sync.Pool

func init() {
	NewsCachePool = &sync.Pool{
		New: func() interface{} {
            // 缓存池修改反序列化
			return gedis.NewSimpeCache(gedis.NewStringOperation(), time.Second*15, gedis.Serilizer_GOB)
		},
	}
}
func NewsCache() *gedis.SimpeCache {
	return NewsCachePool.Get().(*gedis.SimpeCache)
}
func ReleaseNewCache(cache *gedis.SimpeCache) {
	NewsCachePool.Put(cache)
}

```



```go
package gedis

import (
	"bytes"
	"encoding/gob"
	"encoding/json"
	"time"
)

const (
	// 定义json的常量
	Serilizer_JSON = "json"
	Serilizer_GOB  = "gob"
)

type DBGettFunc func() interface{}

type SimpeCache struct {
	Operation *StringOperation
	Exprie    time.Duration
	DBGetter  DBGettFunc
	// 添加json序列化的类型
	Serilizer string
}

func NewSimpeCache(operation *StringOperation, exprie time.Duration, serilizer string) *SimpeCache {
	return &SimpeCache{Operation: operation, Exprie: exprie, Serilizer: serilizer}
}

func (this *SimpeCache) SetCache(key string, value interface{}) {
	this.Operation.Set(key, value, WithExpire(this.Exprie)).Unwrap()
}

// 添加序列化
func (this *SimpeCache) GetCacheForObject(key string, obj interface{}) interface{} {
	ret := this.GetCache(key)
	if ret == nil {
		return nil
	}
	if this.Serilizer == Serilizer_JSON {
		err := json.Unmarshal([]byte(ret.(string)), obj)
		if err != nil {
			return nil
		}
	} else if this.Serilizer == Serilizer_GOB {
		var buf = &bytes.Buffer{}
		buf.WriteString(ret.(string))
		dec := gob.NewDecoder(buf)
		if dec.Decode(obj) != nil {
			return nil
		}
	}
	return nil

}

func (this *SimpeCache) GetCache(key string) (ret interface{}) {
	// 判断Serilizer_JSON的方式
	obj := this.DBGetter()
	if this.Serilizer == Serilizer_JSON {
		// 定义一个匿名参数 获取缓存失败，就去数据库里面取
		f := func() string {

			b, err := json.Marshal(obj)
			if err != nil {
				return ""
			}
			return string(b)

		}
		ret = this.Operation.Get(key).Unwrap_Or_Else(f)
		this.SetCache(key, ret)
	} else if this.Serilizer == Serilizer_GOB {
		f := func() string {
			var buf = &bytes.Buffer{}
			enc := gob.NewEncoder(buf)
			if err := enc.Encode(obj); err != nil {
				return ""
			}
			return buf.String()
		}
		ret = this.Operation.Get(key).Unwrap_Or_Else(f)
		this.SetCache(key, ret)
	}
	return
}

```





```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/shenyisyn/goft-redis/lib"
)

func main() {

	r := gin.New()
	r.Handle("GET", "/news/:id", func(context *gin.Context) {
		newsCache := lib.NewsCache()
		defer lib.ReleaseNewCache(newsCache)
		newsID := context.Param("id")
		newsCache.DBGetter = lib.NewDBGetter(newsID)
		//context.Header("Content-type", "application/json")
		//context.String(200, newsCache.GetCache("name"+newsID).(string))
		newsModel := lib.NewNewsModel()
        // 调用新加的object
		newsCache.GetCacheForObject("name"+newsID, newsModel)
		context.JSON(200, newsModel)
	})
	r.Run(":80")

}

```



结构体对数据库的反编译使用

```go
package lib

import "time"

type NewsModel struct {
	NewsID int `gorm:"column:id" json:"id"`
	NewsTitle string `gorm:"column:newstitle" json:"title"`
	NewsContent string `gorm:"column:newscontent" json:"content"`
	NewsViews int `gorm:"column:views" json:"views"`
	NewsTime time.Time `gorm:"column:addtime" json:"addtime"`
}

func NewNewsModel() *NewsModel {
	return &NewsModel{}
}
```

数据库查询

```go
package lib

import (
	"fmt"
	"github.com/shenyisyn/goft-redis/gedis"
)

func NewDBGetter(id string) gedis.DBGettFunc {
	fmt.Println("use DBGetter")
	return func() interface{} {
		newsModel := NewNewsModel()
		Gorm.Table("mynews").Where("id=?", id).Find(newsModel)
		return newsModel
	}

}

```

数据库初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	"log"
)

var Gorm *gorm.DB

func init() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {
	dsn := "root:123456@tcp(10.165.25.25:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```

缓存池

```go
package lib

import (
	"github.com/shenyisyn/goft-redis/gedis"
	"sync"
	"time"
)

var NewsCachePool *sync.Pool

func init() {
	NewsCachePool = &sync.Pool{
		New: func() interface{} {
			return gedis.NewSimpeCache(gedis.NewStringOperation(), time.Second*15, gedis.Serilizer_GOB)
		},
	}
}
func NewsCache() *gedis.SimpeCache {
	return NewsCachePool.Get().(*gedis.SimpeCache)
}
func ReleaseNewCache(cache *gedis.SimpeCache) {
	NewsCachePool.Put(cache)
}

```

查询结果的处理

```go
package gedis

type StringResult struct {
	Result string
	Err    error
}

func NewStringResult(result string, err error) *StringResult {
	return &StringResult{Result: result, Err: err}
}

func (this *StringResult) Unwrap() string {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *StringResult) Unwrap_or(str string) string {
	if this.Err != nil {
		return str
	}
	return this.Result
}
func (this *StringResult) Unwrap_Or_Else(f func() string) string {

	if this.Err != nil {
		return f()
	}
	//fmt.Println(this.Err)
	return this.Result

}

```

redis的操作

```go
package gedis

import (
	"context"
	"time"
)

//专门处理string类型的操作
type StringOperation struct {
	ctx context.Context
}

func NewStringOperation() *StringOperation {
	return &StringOperation{ctx: context.Background()}
}

func (this *StringOperation) Set(key string, value interface{}, attrs ...*OperationAttr) *InterfaceResult {
	exp := OperationAttrs(attrs).Find(ATTR_EXPIRE)

	nx := OperationAttrs(attrs).Find(ATTR_NX).Unwrap_Or(nil)
	xx := OperationAttrs(attrs).Find(ATTR_XX).Unwrap_Or(nil)
	if nx != nil {
		return NewInterfaceResult(Redis().SetNX(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())
	}
	if xx != nil {
		return NewInterfaceResult(Redis().SetXX(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())
	}
	return NewInterfaceResult(Redis().Set(this.ctx, key, value, exp.Unwrap_Or(time.Second*0).(time.Duration)).Result())

}

func (this *StringOperation) Get(key string) *StringResult {
	return NewStringResult(Redis().Get(this.ctx, key).Result())
}
func (this *StringOperation) MGet(keys ...string) *SliceResult {
	return NewSliceResult(Redis().MGet(this.ctx, keys...).Result())
}

```

redis结果多查询

```go
package gedis

type SliceResult struct {
	Result []interface{}
	Err    error
}

func NewSliceResult(result []interface{}, err error) *SliceResult {
	return &SliceResult{Result: result, Err: err}
}
func (this *SliceResult) Unwrap() []interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *SliceResult) Unwrap_or(v []interface{}) []interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}
func (this *SliceResult) Iter() *Iterator {

	return NewIterator(this.Result)
}

```

迭代器

```go
package gedis

import (
	"fmt"
	"time"
)

type empty struct{}

const (
	ATTR_EXPIRE = "expr" //过期时间
	ATTR_NX     = "nx"   // setnx
	ATTR_XX     = "xx"
)

//属性
type OperationAttr struct {
	Name  string
	Value interface{}
}
type OperationAttrs []*OperationAttr

func (this OperationAttrs) Find(name string) *InterfaceResult {
	for _, attr := range this {
		if attr.Name == name {
			return NewInterfaceResult(attr.Value, nil)
		}
	}
	return NewInterfaceResult(nil, fmt.Errorf("OperationAttrs found error:%s", name))
}
func WithExpire(t time.Duration) *OperationAttr {
	return &OperationAttr{Name: ATTR_EXPIRE, Value: t}
}
func WithNX() *OperationAttr {
	return &OperationAttr{Name: ATTR_NX, Value: empty{}}
}

```

多值返回

```go
package gedis

type Iterator struct {
	data  []interface{}
	index int
}

func NewIterator(data []interface{}) *Iterator {
	return &Iterator{data: data}
}

func (this *Iterator) HasNext() bool {
	// 检测切片是否为最后一个
	if this.data == nil || len(this.data) == 0 {
		return false
	}
	return this.index < len(this.data)
}
func (this *Iterator) Netx() (ret interface{}) {
	ret = this.data[this.index]
	this.index = this.index + 1
	return

}

```



结果的interface返回

```go
package gedis

type InterfaceResult struct {
	Result interface{}
	Err    error
}

func NewInterfaceResult(result interface{}, err error) *InterfaceResult {
	return &InterfaceResult{Result: result, Err: err}
}
func (this *InterfaceResult) Unwrap() interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *InterfaceResult) Unwrap_Or(v interface{}) interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}

```

redis的连接

```go
package gedis

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
	"log"
	"sync"
	"time"
)

var redisClient *redis.Client

// 初始化
var redisClient_Once sync.Once

func Redis() *redis.Client {
	redisClient_Once.Do(func() {
		redisClient = redis.NewClient(&redis.Options{
			Network:  "tcp",
			Addr:     "10.165.25.24:6379",
			Password: "", //密码
			DB:       0,  // redis数据库

			//连接池容量及闲置连接数量
			PoolSize:     15, // 连接池数量
			MinIdleConns: 10, //好比最小连接数
			//超时
			DialTimeout:  5 * time.Second, //连接建立超时时间
			ReadTimeout:  3 * time.Second, //读超时，默认3秒， -1表示取消读超时
			WriteTimeout: 3 * time.Second, //写超时，默认等于读超时
			PoolTimeout:  4 * time.Second, //当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。

			//闲置连接检查包括IdleTimeout，MaxConnAge
			IdleCheckFrequency: 60 * time.Second, //闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。
			IdleTimeout:        5 * time.Minute,  //闲置超时
			MaxConnAge:         0 * time.Second,  //连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接

			//命令执行失败时的重试策略
			MaxRetries:      0,                      // 命令执行失败时，最多重试多少次，默认为0即不重试
			MinRetryBackoff: 8 * time.Millisecond,   //每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔
			MaxRetryBackoff: 512 * time.Millisecond, //每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔

		})
		pong, err := redisClient.Ping(context.Background()).Result()
		if err != nil {
			log.Fatal(fmt.Errorf("connect error:%s", err))
		}
		log.Println(pong)
	})
	return redisClient
}

```

## 13、缓存穿透1

因为有值会查询并缓存，当用户反复查询一个没有的值时，会反复查询数据库

`redis`的缓存穿透是将没有值的数据 置为一个空""



首先对不合法的id进行过滤



```go
package gedis

import "regexp"

type CachePolicy interface {
	Before(key string)
}
type CrossPolicy struct {
	KeyRegx string
}

func NewCrossPolicy(keyRegx string) *CrossPolicy {
	return &CrossPolicy{KeyRegx: keyRegx}
}

func (this *CrossPolicy) Before(key string) {
	if !regexp.MustCompile(this.KeyRegx).MatchString(key) {
		panic("error cache key")
	}

}

```



```go
package gedis

import (
	"bytes"
	"encoding/gob"
	"encoding/json"
	"time"
)

const (
	// 定义json的常量
	Serilizer_JSON = "json"
	Serilizer_GOB  = "gob"
)

type DBGettFunc func() interface{}

type SimpeCache struct {
	Operation *StringOperation
	Exprie    time.Duration
	DBGetter  DBGettFunc
	// 添加json序列化的类型
	Serilizer string
	Policy    CachePolicy
}

func NewSimpeCache(operation *StringOperation, exprie time.Duration, serilizer string, policy CachePolicy) *SimpeCache {
	return &SimpeCache{Operation: operation, Exprie: exprie, Serilizer: serilizer, Policy: policy}
}

func (this *SimpeCache) SetCache(key string, value interface{}) {
	this.Operation.Set(key, value, WithExpire(this.Exprie)).Unwrap()
}

func (this *SimpeCache) GetCacheForObject(key string, obj interface{}) interface{} {
	ret := this.GetCache(key)
	if ret == nil {
		return nil
	}
	if this.Serilizer == Serilizer_JSON {
		err := json.Unmarshal([]byte(ret.(string)), obj)
		if err != nil {
			return nil
		}
	} else if this.Serilizer == Serilizer_GOB {
		var buf = &bytes.Buffer{}
		buf.WriteString(ret.(string))
		dec := gob.NewDecoder(buf)
		if dec.Decode(obj) != nil {
			return nil
		}
	}
	return nil

}

func (this *SimpeCache) GetCache(key string) (ret interface{}) {
	if this.Policy != nil {
		this.Policy.Before(key)
	}

	obj := this.DBGetter()
	if this.Serilizer == Serilizer_JSON {
	
		f := func() string {

			b, err := json.Marshal(obj)
			if err != nil {
				return ""
			}
			return string(b)

		}
		ret = this.Operation.Get(key).Unwrap_Or_Else(f)
		this.SetCache(key, ret)
	} else if this.Serilizer == Serilizer_GOB {
		f := func() string {
			var buf = &bytes.Buffer{}
			enc := gob.NewEncoder(buf)
			if err := enc.Encode(obj); err != nil {
				return ""
			}
			return buf.String()
		}
		ret = this.Operation.Get(key).Unwrap_Or_Else(f)
		this.SetCache(key, ret)
	}
	return
}

```



```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/shenyisyn/goft-redis/lib"
)

func main() {

	r := gin.New()
	r.Use(func(context *gin.Context) {
		defer func() {
			if e := recover(); e != nil {
				context.JSON(400, gin.H{"message": e})
			}
		}()
		context.Next()
	})
	r.Handle("GET", "/news/:id", func(context *gin.Context) {
		newsCache := lib.NewsCache()
		defer lib.ReleaseNewCache(newsCache)
		newsID := context.Param("id")
		newsCache.DBGetter = lib.NewDBGetter(newsID)
		newsModel := lib.NewNewsModel()
		newsCache.GetCacheForObject("news"+newsID, newsModel)
		context.JSON(200, newsModel)
	})
	r.Run(":80")

}

```



```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/shenyisyn/goft-redis/lib"
)

func main() {

	r := gin.New()
	r.Use(func(context *gin.Context) {
		defer func() {
			if e := recover(); e != nil {
				context.JSON(400, gin.H{"message": e})
			}
		}()
		context.Next()
	})
	r.Handle("GET", "/news/:id", func(context *gin.Context) {
		newsCache := lib.NewsCache()
		defer lib.ReleaseNewCache(newsCache)
		newsID := context.Param("id")
		newsCache.DBGetter = lib.NewDBGetter(newsID)
		newsModel := lib.NewNewsModel()
		newsCache.GetCacheForObject("news"+newsID, newsModel)
		context.JSON(200, newsModel)
	})
	r.Run(":80")

}

```



## 14、缓存穿透2-全

`redis`的封装

`redis`初始化

```go
package gedis

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
	"log"
	"sync"
	"time"
)

var redisClient *redis.Client
var redisClient_Once sync.Once

func Redis() *redis.Client {
	redisClient_Once.Do(func() {
		redisClient = redis.NewClient(&redis.Options{
			Network:  "tcp",
			Addr:     "10.165.25.24:6379",
			Password: "", //密码
			DB:       0,  // redis数据库

			//连接池容量及闲置连接数量
			PoolSize:     15, // 连接池数量
			MinIdleConns: 10, //好比最小连接数
			//超时
			DialTimeout:  5 * time.Second, //连接建立超时时间
			ReadTimeout:  3 * time.Second, //读超时，默认3秒， -1表示取消读超时
			WriteTimeout: 3 * time.Second, //写超时，默认等于读超时
			PoolTimeout:  4 * time.Second, //当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。

			//闲置连接检查包括IdleTimeout，MaxConnAge
			IdleCheckFrequency: 60 * time.Second, //闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。
			IdleTimeout:        5 * time.Minute,  //闲置超时
			MaxConnAge:         0 * time.Second,  //连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接

			//命令执行失败时的重试策略
			MaxRetries:      0,                      // 命令执行失败时，最多重试多少次，默认为0即不重试
			MinRetryBackoff: 8 * time.Millisecond,   //每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔
			MaxRetryBackoff: 512 * time.Millisecond, //每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔

		})
		pong, err := redisClient.Ping(context.Background()).Result()
		if err != nil {
			log.Fatal(fmt.Errorf("connect error:%s", err))
		}
		log.Println(pong)
	})
	return redisClient
}

```

结果的封装与返回

```go
package gedis

type InterfaceResult struct {
	Result interface{}
	Err    error
}

func NewInterfaceResult(result interface{}, err error) *InterfaceResult {
	return &InterfaceResult{Result: result, Err: err}
}

// panic错误
func (this *InterfaceResult) Unwrap() interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}

// 返回默认值
func (this *InterfaceResult) Unwrap_Or(v interface{}) interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}

// 如果执行错误, 就返回函数f的值
func (this *InterfaceResult) Unwrap_Or_Else(f func() interface{}) interface{} {
	if this.Err != nil {
		return f()
	}
	return this.Result
}

```

`string`类型结果的封装与返回

```go
package gedis

type Result interface {
	Unwrap()
}
type StringResult struct {
	Result string
	Err error
}
func NewStringResult(result string, err error) *StringResult {
	return &StringResult{Result: result, Err: err}
}
func(this *StringResult) Unwrap() string {
		if this.Err!=nil{
		    panic(this.Err)
		}
		return this.Result
}
func(this *StringResult) Unwrap_Or(str string) string {
	if this.Err!=nil{
		return str
	}
	return this.Result
}
func(this *StringResult) Unwrap_Or_Else(f func() string) string{
	if this.Err!=nil{
		return f()
	}
	return this.Result
}

```

迭代器

```go
package gedis

type Iterator struct {
	data []interface{}
	index int 
}

func NewIterator(data []interface{}) *Iterator {
	return &Iterator{data: data}
}
func(this *Iterator) HasNext() bool{
	 if this.data==nil || len(this.data)==0{
	 	return false
	 }
	 return this.index<len(this.data)
}
func(this *Iterator) Next() (ret interface{}){
	ret=this.data[this.index]
	this.index=this.index+1
	return
}
```

`Slice`的结果

```go
package gedis

type SliceResult struct {
	Result []interface{}
	Err    error
}

func NewSliceResult(result []interface{}, err error) *SliceResult {
	return &SliceResult{Result: result, Err: err}
}
func (this *SliceResult) Unwrap() []interface{} {
	if this.Err != nil {
		panic(this.Err)
	}
	return this.Result
}
func (this *SliceResult) Unwrap_Or(v []interface{}) []interface{} {
	if this.Err != nil {
		return v
	}
	return this.Result
}

// 调用迭代器
func (this *SliceResult) Iter() *Iterator {
	return NewIterator(this.Result)
}

```

设定常量，对`redis`新增功能字段

```go
package gedis

import (
	"fmt"
	"time"
)

type empty struct {}
const (
	ATTR_EXPIRE="expr"   //过期时间
	ATTR_NX ="nx"  // setnx
	ATTR_XX ="xx"  // setxx
)
//属性
type OperationAttr struct {
	Name string
	Value interface{}
}
type OperationAttrs []*OperationAttr
func(this OperationAttrs) Find(name string) *InterfaceResult{
	 for _,attr:=range this {
	 	if attr.Name==name{
	 		return NewInterfaceResult(attr.Value,nil)
		}
	 }
	 return NewInterfaceResult(nil,fmt.Errorf("OperationAttrs found error:%s",name))
}
func WithExpire(t time.Duration) *OperationAttr  {
		return &OperationAttr{Name:ATTR_EXPIRE,Value:t}
}
func WithNX() *OperationAttr  {
	return &OperationAttr{Name:ATTR_NX,Value:empty{}}
}
func WithXX() *OperationAttr  {
	return &OperationAttr{Name:ATTR_XX,Value:empty{}}
}

```

`redis`的主操作方法



```go
package gedis

import (
	"context"
	"time"
)

//专门处理string类型的操作
type StringOperation struct {
	ctx context.Context
}

func NewStringOperation() *StringOperation {
	return &StringOperation{ctx: context.Background()}
}

// 支持多方式传入
func (this *StringOperation) Set(key string, value interface{}, attrs ...*OperationAttr) *InterfaceResult {
	// 查找设置的时间
	exp := OperationAttrs(attrs).Find(ATTR_EXPIRE).Unwrap_Or(time.Second * 0).(time.Duration)
	// 是否NX的方式
	nx := OperationAttrs(attrs).Find(ATTR_NX).Unwrap_Or(nil)
	if nx != nil {
		return NewInterfaceResult(Redis().SetNX(this.ctx, key, value, exp).Result())
	}
	// 是否XX的方式
	xx := OperationAttrs(attrs).Find(ATTR_XX).Unwrap_Or(nil)
	if xx != nil {
		return NewInterfaceResult(Redis().SetXX(this.ctx, key, value, exp).Result())
	}
	//
	return NewInterfaceResult(Redis().Set(this.ctx, key, value, exp).Result())

}

// 查询key
func (this *StringOperation) Get(key string) *StringResult {
	return NewStringResult(Redis().Get(this.ctx, key).Result())
}

// 查询多key
func (this *StringOperation) MGet(keys ...string) *SliceResult {
	return NewSliceResult(Redis().MGet(this.ctx, keys...).Result())
}

```



策略对缓存传递

```go
package gedis

import (
	"regexp"
	"time"
)

type CachePolicy interface {
	Before(key string )
	IfNil(key string,v interface{})
	SetOperation(opt *StringOperation) //今日改动点
}

//缓存穿透 策略
type CrossPolicy struct {
	KeyRegx string  //检查key的正则
	Expire time.Duration
	opt *StringOperation
}

func NewCrossPolicy(keyRegx string,expire time.Duration) *CrossPolicy {
	return &CrossPolicy{KeyRegx: keyRegx,Expire:expire}
}

func (this *CrossPolicy) Before(key string )  {
		if !regexp.MustCompile(this.KeyRegx).MatchString(key){
			panic("error cache key")
		}
}
func(this *CrossPolicy) IfNil(key string,v interface{})  {
	 	this.opt.Set(key,v,WithExpire(this.Expire)).Unwrap()

}
func(this *CrossPolicy) SetOperation(opt *StringOperation){
	this.opt=opt
}
```

缓冲的处理调用`redis`的各种方法

```go
package gedis

import (
	"bytes"
	"encoding/gob"
	"encoding/json"
	"time"
)

const (
	Serilizer_JSON="json"
	Serilizer_GOB="gob"
)

type DBGetterFunc func() interface{}
type SimpleCache struct {
	Operation *StringOperation  //操作类
	Expire time.Duration  // 过期时间
	DBGetter  DBGetterFunc // 一旦缓存中没有  DB获取的方法
	Serilizer string  // 序列化方式
	Policy CachePolicy
}
func NewSimpleCache(operation *StringOperation, expire time.Duration, serilizer string,policy CachePolicy) *SimpleCache {
	 policy.SetOperation(operation)
	return &SimpleCache{Operation: operation, Expire: expire, Serilizer: serilizer,Policy:policy}
}


// 设置缓存
func(this *SimpleCache) SetCache(key string ,value interface{}){
	this.Operation.Set(key,value,WithExpire(this.Expire)).Unwrap()
}
func(this *SimpleCache) GetCacheForObject(key string,obj interface{})  interface{} {
	ret:=this.GetCache(key)
	if ret==nil {
		return nil
	}
	if this.Serilizer==Serilizer_JSON{
		err:=json.Unmarshal([]byte(ret.(string)),obj)
		if err!=nil{
			return nil
		}
	}else if   this.Serilizer==Serilizer_GOB{
		var buf =&bytes.Buffer{}
		buf.WriteString(ret.(string))
		dec:=gob.NewDecoder(buf)
		if dec.Decode(obj)!=nil{
			return nil
		}
	}
	return nil
}

func(this *SimpleCache) GetCache(key string) (ret interface{}){
	if this.Policy!=nil{ //检查策略
		this.Policy.Before(key)
	}
	if this.Serilizer==Serilizer_JSON{
		f:= func()  string {
		    obj:= this.DBGetter()
		    if obj==nil{
		    	return ""
			}
			b,err:=json.Marshal(obj)
			if err!=nil{
				return ""
			}
			return string(b)
		}
		ret=this.Operation.Get(key).Unwrap_Or_Else(f)
		//this.SetCache(key,ret)
	}else if this.Serilizer==Serilizer_GOB {
		f := func() string {
			obj:= this.DBGetter()
			if obj==nil{
				return ""
			}
			var buf= &bytes.Buffer{}
			enc := gob.NewEncoder(buf)
			if err := enc.Encode(obj); err != nil {
				return ""
			}
			return buf.String()
		}
		ret = this.Operation.Get(key).Unwrap_Or_Else(f)
		//this.SetCache(key, ret)
	}

	   if ret.(string)=="" && this.Policy!=nil {  //执行ifnil策略
	   	  this.Policy.IfNil(key,"")

	   }else{
		   this.SetCache(key, ret)
	   }
		return
}
```





数据库

`redis`缓存池

```go
package lib

import (
	"gedis/gedis"
	"sync"
	"time"
)

var NewsCachePool *sync.Pool

func init() {
	NewsCachePool = &sync.Pool{
		New: func() interface{} {
			return gedis.NewSimpleCache(gedis.NewStringOperation(), time.Second*150,
				gedis.Serilizer_JSON,
				gedis.NewCrossPolicy("^news\\d{1,5}$", time.Second*30)) // 指定序列化 是JSON，缓存穿透设置
		},
	}
}
func NewsCache() *gedis.SimpleCache {
	return NewsCachePool.Get().(*gedis.SimpleCache)
}
func ReleaseNewsCache(cache *gedis.SimpleCache) {
	NewsCachePool.Put(cache)
}

```

数据库的初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	"log"
)

var Gorm *gorm.DB

func init() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {
	dsn := "root:123456@tcp(10.165.25.25:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```



数据库调用查询

```go
package lib

import (
	"gedis/gedis"
	"log"
)

func NewsDBGetter(id string) gedis.DBGetterFunc {
	return func() interface{} {
		log.Println("get from db")
		newsModel := NewNewsModel()
		//Gorm.Table("mynews").Where("id=?",id).Find(newsModel)
		//return newsModel
		if Gorm.Table("mynews").
			Where("id=?", id).Find(newsModel).Error != nil || newsModel.NewsID <= 0 {
			return nil
		}
		return newsModel
	}

}

```

结构体反编译

```go
package lib

import (
	"log"
	"time"
)

type NewsModel struct {
	NewsID int `gorm:"column:id" json:"id"`
	NewsTitle string `gorm:"column:newstitle" json:"title"`
	NewsContent string `gorm:"column:newscontent" json:"content"`
	NewsViews int `gorm:"column:views" json:"views"`
	NewsTime time.Time `gorm:"column:addtime" json:"addtime"`
}
func NewNewsModel() *NewsModel {
	return &NewsModel{}
}
func(this *NewsModel) Test(){
	log.Println("data from NewsModel")
}
```



主函数

```go
package main

import (
	"gedis/lib"
	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.New()
	r.Use(func(context *gin.Context) {
		defer func() {
			if e := recover(); e != nil {
				context.JSON(400, gin.H{"message": e})
			}
		}()
		context.Next()
	})
	r.Handle("GET", "/news/:id", func(context *gin.Context) {
		// 1、从对象池 获取新闻缓存 对象
		newsCache := lib.NewsCache()
		defer lib.ReleaseNewsCache(newsCache)

		//2、获取参数，设置DBGetter
		newsID := context.Param("id")
		newsCache.DBGetter = lib.NewsDBGetter(newsID) //一旦缓存没有，则需要从哪去取

		// 3、取缓存输出（一旦没有，上面的DBGetter会被调用)
		newsModel := lib.NewNewsModel()
		newsCache.GetCacheForObject("news"+newsID, newsModel)
		context.JSON(200, newsModel)
	})

	r.Run(":8080")

}

```

