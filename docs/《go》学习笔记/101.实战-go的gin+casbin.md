---
title: go的gin+casbin
date: 2022-05-18 16:19:34
permalink: /pages/go101/
categories:
  - 《go》学习笔记
tags:
  - go
---







## 1、什么是casbin

  Casbin是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型

[官方地址](https://casbin.org/docs/zh-CN/overview
)

使用

```go
go get github.com/gin-gonic/gin
go get github.com/casbin/casbin

```

模型数据

```go
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act

```

```
解释

[request_definition]

r = sub, obj, act
访问实体 (Subject)，访问资源 (Object) 和访问方法 (Action)


[policy_definition]
p = sub, obj, act

效果一样  是对策略的定义


[policy_effect]
e = some(where (p.eft == allow))
 
对policy生效范围的定义
上面表示：如果存在任意一个决策结果为allow的匹配规则，则最终决策结果为allow

p.eft就是决策结果

示例
!some(where (p.eft == deny))  表示 任何一个决策结果都不能是deny

[role_definition]  角色定义
g = _, _



_, _表示角色继承关系的前项和后项，即前项继承后项角色的权限

admin >=member
member>=guest


[matchers]
m = r.sub == p.sub && r.obj == p.obj && r.act == p.act

这个是 请求和策略的匹配规则


```

策略文件

```

p, member, /depts, GET
p, member, /depts/:id, GET

p, admin, /depts, POST
p, admin, /depts/:id, PUT
p, admin, /depts/:id, DELETE

g, admin, member
g, xiongmao, admin
g, lisi, member

```



```
g, xiongmao, admin
g, lisi, member
//上面这两个 代表定义了两个人：xiongmao和lisi ，分表角色是admin和member

p, memeber, /depts, GET
p, memeber, /depts/:id, GET
//这代表 member可以访问的 path和请求方式
p, admin, /depts, POST
p, admin, /depts/:id, PUT
p, admin, /depts/:id, DELETE
//同上 
 g, admin, member
 g,member,guest
这代表 admin同时也拥有member的关系 

```

代码

```go
package main

import (
	"github.com/casbin/casbin"
	"log"
)

func main() {
	// /depts
	sub := "xiongmao" // 想要访问资源的用户。
	obj := "/depts"   // 将被访问的资源。
	act := "POST"     // 用户对资源执行的操作。
	e := casbin.NewEnforcer("resources/model.conf", "resources/p.csv")

	ok := e.Enforce(sub, obj, act)
	if ok {
		log.Println("运行通过")
	}

}

```

## 2、GIN+CASBIN的引用

新增中间件

```go
package lib

import (
	"github.com/casbin/casbin"
	"github.com/gin-gonic/gin"
)

func CheckLogin() gin.HandlerFunc {
	return func(context *gin.Context) {
		if context.Request.Header.Get("token") == "" {
			context.AbortWithStatusJSON(400, gin.H{"message": "token required"})
		} else {
			context.Set("user_name", context.Request.Header.Get("token"))
			context.Next()
		}
	}

}

func RBAC() gin.HandlerFunc {
	e := casbin.NewEnforcer("resources/model.conf", "resources/p.csv")
	return func(context *gin.Context) {
		user, _ := context.Get("user_name")
        // 判断是否符合casbin的要求
		if !e.Enforce(user, context.Request.RequestURI, context.Request.Method) {
			context.AbortWithStatusJSON(403, gin.H{"message": "forbidden"})
		} else {
			context.Next()
		}

	}
}

func Middlewares() (fs []gin.HandlerFunc) {
	fs = append(fs, CheckLogin(), RBAC())
	return
}

```







```go
package main

import (
	"casbin/lib"
	"github.com/gin-gonic/gin"
)

func main() {

	r := gin.New()
    // 使用中间件
	r.Use(lib.Middlewares()...)
	r.GET("/depts", func(context *gin.Context) {
		context.JSON(200, gin.H{"result": "部门列表"})
	})
	r.POST("/depts", func(context *gin.Context) {
		context.JSON(200, gin.H{"result": "部门列表"})
	})
	r.Run(":80")
}

```





测试效果

![image-20220509152952016](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205091530481.png)

## 3、GIN+GORM+CASBIN的引用

下载依赖

[服务](github.com/casbin/gorm-adapter/)

```go
go get github.com/casbin/casbin/v2
go get github.com/casbin/gorm-adapter/v3
```



数据库的初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"log"
)

var Gorm *gorm.DB

func init() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {

	dsn := "root:123456@tcp(10.165.25.25:3307)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```



中间件的修改

```go
package lib

import (
	"github.com/casbin/casbin/v2"
	"github.com/casbin/gorm-adapter/v3"
	"github.com/gin-gonic/gin"
	"log"
)

// 检查登录名不为空
func CheckLogin() gin.HandlerFunc {
	return func(context *gin.Context) {
		if context.Request.Header.Get("token") == "" {
			context.AbortWithStatusJSON(400, gin.H{"message": "token required"})
		} else {
			context.Set("user_name", context.Request.Header.Get("token"))
			context.Next()
		}
	}
}

// 对gorm的调用
func RBAC() gin.HandlerFunc {
	// e:= casbin.NewEnforcer("resources/model.conf","resources/p.csv")
	// 调用数据库
	adapter, err := gormadapter.NewAdapterByDB(Gorm)

	if err != nil {
		log.Fatal()
	}
	//
	e, err := casbin.NewEnforcer("resources/model.conf", adapter)
	if err != nil {
		log.Fatal()
	}
	err = e.LoadPolicy()
	if err != nil {
		log.Fatal()
	}

	return func(context *gin.Context) {
        // 获取CheckLogin()值
		user, _ := context.Get("user_name")
        // 判断是否有权限
		access, err := e.Enforce(user, context.Request.RequestURI, context.Request.Method)
		if err != nil || !access {
			context.AbortWithStatusJSON(403, gin.H{"message": "forbidden"})
		} else {
			context.Next()
		}
	}
}

// 整合列表
func Middlewares() (fs []gin.HandlerFunc) {
	fs = append(fs, CheckLogin(), RBAC())
	return
}

```



会自动生成cabin_rule的表

![image-20220509170939251](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205091709789.png)



格式如下

```mysql
CREATE TABLE `casbin_rule` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `ptype` varchar(100) DEFAULT NULL,
  `v0` varchar(100) DEFAULT NULL,
  `v1` varchar(100) DEFAULT NULL,
  `v2` varchar(100) DEFAULT NULL,
  `v3` varchar(100) DEFAULT NULL,
  `v4` varchar(100) DEFAULT NULL,
  `v5` varchar(100) DEFAULT NULL,
  `v6` varchar(25) DEFAULT NULL,
  `v7` varchar(25) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_casbin_rule` (`ptype`,`v0`,`v1`,`v2`,`v3`,`v4`,`v5`,`v6`,`v7`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```



对人员数据库的填写

![image-20220509171644563](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205091716908.png)

测试结果

![image-20220509171713896](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205091717136.png)

## 4、新增策略初始化

数据库的初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"log"
)

var Gorm *gorm.DB

func initDB() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {

	dsn := "root:123456@tcp(10.165.25.25:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```

对中间件的调用

```go
package lib

import (
	"github.com/gin-gonic/gin"
)

// 检查登录名不为空
func CheckLogin() gin.HandlerFunc {
	return func(context *gin.Context) {
		if context.Request.Header.Get("token") == "" {
			context.AbortWithStatusJSON(400, gin.H{"message": "token required"})
		} else {
			context.Set("user_name", context.Request.Header.Get("token"))
			context.Next()
		}
	}
}

// 对gorm的调用
func RBAC() gin.HandlerFunc {
	return func(context *gin.Context) {
		user, _ := context.Get("user_name")
		access, err := E.Enforce(user, context.Request.RequestURI, context.Request.Method)
		if err != nil || !access {
			context.AbortWithStatusJSON(403, gin.H{"message": "forbidden"})
		} else {
			context.Next()
		}
	}
}

// 整合列表
func Middlewares() (fs []gin.HandlerFunc) {
	fs = append(fs, CheckLogin(), RBAC())
	return
}

```





```go
package lib

import (
	"github.com/casbin/casbin/v2"
	"github.com/casbin/gorm-adapter/v3"
	"log"
)
var E *casbin.Enforcer
func init() {
	initDB()
    // 对gorm的引用
	adapter,err:=gormadapter.NewAdapterByDB( Gorm)
	if err!=nil{
		log.Fatal()
	}
    // 对casbin数据模型的调用
	e,err:= casbin.NewEnforcer("resources/model.conf",adapter)
	if err!=nil{
		log.Fatal()
	}
    // 必须load策略
	err=e.LoadPolicy()
	if err!=nil{
		log.Fatal()
	}
	E=e
	initPolicy()
}
//从我们的库里初始化 策略数据
func initPolicy()  {
	E.AddPolicy("member","/depts","GET")
	E.AddPolicy("admin","/depts","POST")
	E.AddRoleForUser("zhangsan","member")
    E.AddRoleForUser("wangwu", "member")
}

```

查看自动输入到数据库的条目

![image-20220511170727004](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205111707570.png)



数据表构建

![image-20220512095719477](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205120957367.png)

## 5、表的设计

```go
/*
 Navicat Premium Data Transfer

 Source Server         : mysql57
 Source Server Type    : MySQL
 Source Server Version : 50721
 Source Host           : localhost:3307
 Source Schema         : mytest

 Target Server Type    : MySQL
 Target Server Version : 50721
 File Encoding         : 65001

 Date: 28/09/2020 19:35:15
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for roles
-- ----------------------------
DROP TABLE IF EXISTS `roles`;
CREATE TABLE `roles`  (
  `role_id` int(11) NOT NULL AUTO_INCREMENT,
  `role_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `role_pid` int(11) NULL DEFAULT 0,
  `role_comment` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  PRIMARY KEY (`role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of roles
-- ----------------------------
INSERT INTO `roles` VALUES (1, 'guest', 0, '游客');
INSERT INTO `roles` VALUES (2, 'sysadmin', 0, '系统管理员');
INSERT INTO `roles` VALUES (3, 'deptadmin', 2, '部门管理员');
INSERT INTO `roles` VALUES (4, 'useradmin', 2, '会员总管理员');
INSERT INTO `roles` VALUES (5, 'frontadmin', 4, '前台会员管理员');
INSERT INTO `roles` VALUES (6, 'backendadmin', 4, '后台会员管理员');

-- ----------------------------
-- Table structure for router_roles
-- ----------------------------
DROP TABLE IF EXISTS `router_roles`;
CREATE TABLE `router_roles`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `router_id` int(11) NULL DEFAULT NULL,
  `role_id` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `router_id`(`router_id`, `role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of router_roles
-- ----------------------------
INSERT INTO `router_roles` VALUES (1, 1, 3);
INSERT INTO `router_roles` VALUES (2, 1, 4);
INSERT INTO `router_roles` VALUES (5, 3, 3);
INSERT INTO `router_roles` VALUES (3, 5, 3);
INSERT INTO `router_roles` VALUES (4, 5, 4);
INSERT INTO `router_roles` VALUES (6, 7, 4);

-- ----------------------------
-- Table structure for routers
-- ----------------------------
DROP TABLE IF EXISTS `routers`;
CREATE TABLE `routers`  (
  `r_id` int(11) NOT NULL AUTO_INCREMENT,
  `r_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `r_uri` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `r_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `r_status` tinyint(4) NULL DEFAULT NULL,
  PRIMARY KEY (`r_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of routers
-- ----------------------------
INSERT INTO `routers` VALUES (1, '部门列表', '/detps', 'GET', 1);
INSERT INTO `routers` VALUES (2, '部门详细', '/depts/:id', 'GET', 1);
INSERT INTO `routers` VALUES (3, '新增部门', '/depts', 'POST', 1);
INSERT INTO `routers` VALUES (5, '会员列表', '/users', 'GET', 1);
INSERT INTO `routers` VALUES (6, '会员详细', '/users/:id', 'GET', 1);
INSERT INTO `routers` VALUES (7, '新增会员', '/users', 'POST', 1);

-- ----------------------------
-- Table structure for user_roles
-- ----------------------------
DROP TABLE IF EXISTS `user_roles`;
CREATE TABLE `user_roles`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `role_id` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `user_id`(`user_id`, `role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_roles
-- ----------------------------
INSERT INTO `user_roles` VALUES (1, 1, 2);
INSERT INTO `user_roles` VALUES (2, 2, 3);
INSERT INTO `user_roles` VALUES (3, 3, 4);

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users`  (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  PRIMARY KEY (`user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of users
-- ----------------------------
INSERT INTO `users` VALUES (1, 'xiongmao');
INSERT INTO `users` VALUES (2, 'lisi');
INSERT INTO `users` VALUES (3, 'zhangsan');

SET FOREIGN_KEY_CHECKS = 1;

```

role表

![image-20220512144802645](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205121448157.png)

## 6、role表

数据库的初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"log"
)

var Gorm *gorm.DB

func initDB() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {

	dsn := "root:123456@tcp(10.165.25.25:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```

```go
//中间件
package lib

import (
	"github.com/gin-gonic/gin"
)

// 检查登录名不为空
func CheckLogin() gin.HandlerFunc {
	return func(context *gin.Context) {
		if context.Request.Header.Get("token") == "" {
			context.AbortWithStatusJSON(400, gin.H{"message": "token required"})
		} else {
			context.Set("user_name", context.Request.Header.Get("token"))
			context.Next()
		}
	}
}

// 对gorm的调用
func RBAC() gin.HandlerFunc {
	return func(context *gin.Context) {
		user, _ := context.Get("user_name")
		access, err := E.Enforce(user, context.Request.RequestURI, context.Request.Method)
		if err != nil || !access {
			context.AbortWithStatusJSON(403, gin.H{"message": "forbidden"})
		} else {
			context.Next()
		}
	}
}

// 整合列表
func Middlewares() (fs []gin.HandlerFunc) {
	fs = append(fs, CheckLogin(), RBAC())
	return
}

```

对role表的自动写入

```go
package lib

import (
	"github.com/casbin/casbin/v2"
	"github.com/casbin/gorm-adapter/v3"
	"log"
)

var E *casbin.Enforcer

func init() {
	initDB()
	adapter, err := gormadapter.NewAdapterByDB(Gorm)
	if err != nil {
		log.Fatal()
	}
	e, err := casbin.NewEnforcer("resources/model.conf", adapter)
	if err != nil {
		log.Fatal()
	}
	err = e.LoadPolicy()
	if err != nil {
		log.Fatal()
	}
	E = e
	initPolicy()
}

//从我们的库里初始化 策略数据
func initPolicy() {
	/*
		E.AddPolicy("member", "/depts", "GET")
		E.AddPolicy("admin", "/depts", "POST")
		E.AddRoleForUser("zhangsan", "member")
		E.AddRoleForUser("wangwu", "member")
	*/
	m := make([]*RoleRel, 0)
	GetRoles(0, &m, "") //获取角色对应的权限
	for _, r := range m {
		E.AddRoleForUser(r.PRole, r.Role) //添加角色
	}
}

```

对RBAC的表

```go
package lib

import (
	"casbin/models"
)

type RoleRel struct {
	PRole string
	Role  string
}

func (this *RoleRel) String() string {
	return this.PRole + ":" + this.Role
}

//获取角色
func GetRoles(pid int, m *[]*RoleRel, pname string) {
	proles := make([]*models.Role, 0)
	// 获取角色
	Gorm.Where("role_pid=?", pid).Find(&proles)

	// 未获取到直接退出
	if len(proles) == 0 {
		return
	}
	// 遍历role_pid0开始到，获取到role_id
	for _, item := range proles {

		if pname != "" {
			*m = append(*m, &RoleRel{pname, item.RoleName})
		}
		// 递归
		GetRoles(item.RoleId, m, item.RoleName)
	}

}

```

![image-20220512191410251](C:/Users/keda/AppData/Roaming/Typora/typora-user-images/image-20220512191410251.png)

main对初始化

```GO
package main

import (
	"casbin/lib"
	"fmt"
)

func main() {
	/*
		r := gin.New()
		r.Use(lib.Middlewares()...)
		r.GET("/depts", func(context *gin.Context) {
			context.JSON(200, gin.H{"result": "部门列表"})
		})
		r.POST("/depts", func(context *gin.Context) {
			context.JSON(200, gin.H{"result": "部门列表"})
		})
		r.Run(":80")
	*/
	m := make([]*lib.RoleRel, 0)
	lib.GetRoles(0, &m, "")
	fmt.Println(m)
}

```



## 7、初始化权限(2):用户和角色初始化

依赖权限模型

```
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act

```

角色表的解析

```go
package models

import "fmt"

// 创建接收角色的结构体
type Role struct {
	RoleId      int    `gorm:"column:role_id;primaryKey"`
	RoleName    string `gorm:"column:role_name"`
	RolePid     int    `gorm:"column:role_pid;"`
	RoleComment string `gorm:"column:role_comment"`
}

func (this *Role) TableName() string {
	return "roles"
}
func (this *Role) String() string {
	return fmt.Sprintf("ID:%d 角色名:%s", this.RoleId, this.RoleName)
}

```

用户表的解析

```go
package models

import "fmt"

type Users struct {
	UserID   int    `gorm:"column:user_id;primaryKey"`
	UserName string `gorm:"user_name"`
	RoleName string 
    //默认gorm为role_name
}

func (this *Users) TableName() string {
	return "users"
}
func (this *Users) String() string {
	return fmt.Sprintf("%s-%s", this.UserName, this.RoleName)
}
```

数据库初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"log"
)

var Gorm *gorm.DB

func initDB() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {

	dsn := "root:123456@tcp(10.165.25.25:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```

中间件

```go
package lib

import (
	"github.com/gin-gonic/gin"
)

// 检查登录名不为空
func CheckLogin() gin.HandlerFunc {
	return func(context *gin.Context) {
		if context.Request.Header.Get("token") == "" {
			context.AbortWithStatusJSON(400, gin.H{"message": "token required"})
		} else {
			context.Set("user_name", context.Request.Header.Get("token"))
			context.Next()
		}
	}
}

// 对gorm的调用
func RBAC() gin.HandlerFunc {
	return func(context *gin.Context) {
		user, _ := context.Get("user_name")
		access, err := E.Enforce(user, context.Request.RequestURI, context.Request.Method)
		if err != nil || !access {
			context.AbortWithStatusJSON(403, gin.H{"message": "forbidden"})
		} else {
			context.Next()
		}
	}
}

// 整合列表
func Middlewares() (fs []gin.HandlerFunc) {
	fs = append(fs, CheckLogin(), RBAC())
	return
}

```

用户与角色的初始化

```go
package lib

import (
	"casbin/models"
)

type RoleRel struct {
	PRole string
	Role  string
}

func (this *RoleRel) String() string {
	return this.PRole + ":" + this.Role
}

//获取角色
func GetRoles(pid int, m *[]*RoleRel, pname string) {
	proles := make([]*models.Role, 0)
	// 获取角色
	Gorm.Where("role_pid=?", pid).Find(&proles)

	// 未获取到直接退出
	if len(proles) == 0 {
		return
	}
	// 遍历role_pid0开始到，获取到role_id
	for _, item := range proles {

		if pname != "" {
			*m = append(*m, &RoleRel{pname, item.RoleName})
		}
		// 递归
		GetRoles(item.RoleId, m, item.RoleName)
	}

}

//models包中的User
func GetUserRoles() (users []*models.Users) {

	Gorm.Select("a.user_name,c.role_name").Table("users a,user_roles b,roles c").Where("a.user_id=b.user_id and b.role_id=c.role_id").Order("a.user_id desc").Find(&users)
	return
}

```

表的关系

![image-20220517153900518](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205171539092.png)

RBAC的初始化

```go
package lib

import (
	"github.com/casbin/casbin/v2"
	"github.com/casbin/gorm-adapter/v3"
	"log"
)

var E *casbin.Enforcer

func init() {
	initDB()
	adapter, err := gormadapter.NewAdapterByDB(Gorm)
	if err != nil {
		log.Fatal()
	}
	e, err := casbin.NewEnforcer("resources/model.conf", adapter)
	if err != nil {
		log.Fatal()
	}
	err = e.LoadPolicy()
	if err != nil {
		log.Fatal()
	}
	E = e
	initPolicy()
}

//从我们的库里初始化 策略数据
func initPolicy() {

	m := make([]*RoleRel, 0)
	GetRoles(0, &m, "") //获取角色对应的权限
	for _, r := range m {
		_, err := E.AddRoleForUser(r.PRole, r.Role) //添加角色
		if err != nil {
			log.Fatal(err)
		}
	}
    // 调用数据库查找的信息
	userRole := GetUserRoles()
	for _, ur := range userRole {
		_, err := E.AddRoleForUser(ur.UserName, ur.RoleName) //添加角色
		if err != nil {
			log.Fatal(err)
		}
	}
}

```



```go
package main

import (
	"casbin/lib"
	"fmt"
)

func main() {
	/*
		r := gin.New()
		r.Use(lib.Middlewares()...)
		r.GET("/depts", func(context *gin.Context) {
			context.JSON(200, gin.H{"result": "部门列表"})
		})
		r.POST("/depts", func(context *gin.Context) {
			context.JSON(200, gin.H{"result": "部门列表"})
		})
		r.Run(":80")
	*/
	m := make([]*lib.RoleRel, 0)
	lib.GetRoles(0, &m, "")
	fmt.Println(m)
}

```



结果

![image-20220517135723617](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205171357171.png)





添加后

![image-20220517135424493](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205171354152.png)

![image-20220517135450077](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205171354546.png)

## 8、初始化权限(3):路由和角色初始化、uri参数支持

数据库依赖

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"log"
)

var Gorm *gorm.DB

func initDB() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {

	dsn := "root:123456@tcp(10.165.25.25:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```

中间件

```go
package lib

import (
	"github.com/gin-gonic/gin"
)

// 检查登录名不为空
func CheckLogin() gin.HandlerFunc {
	return func(context *gin.Context) {
		if context.Request.Header.Get("token") == "" {
			context.AbortWithStatusJSON(400, gin.H{"message": "token required"})
		} else {
			context.Set("user_name", context.Request.Header.Get("token"))
			context.Next()
		}
	}
}

// 对gorm的调用
func RBAC() gin.HandlerFunc {
	return func(context *gin.Context) {
		user, _ := context.Get("user_name")
		access, err := E.Enforce(user, context.Request.RequestURI, context.Request.Method)
		if err != nil || !access {
			context.AbortWithStatusJSON(403, gin.H{"message": "forbidden"})
		} else {
			context.Next()
		}
	}
}

// 整合列表
func Middlewares() (fs []gin.HandlerFunc) {
	fs = append(fs, CheckLogin(), RBAC())
	return
}

```

新增路由获取

```go
package lib

import (
	"casbin/models"
)

type RoleRel struct {
	PRole string
	Role  string
}

func (this *RoleRel) String() string {
	return this.PRole + ":" + this.Role
}

//获取角色
func GetRoles(pid int, m *[]*RoleRel, pname string) {
	proles := make([]*models.Role, 0)
	// 获取角色
	Gorm.Where("role_pid=?", pid).Find(&proles)

	// 未获取到直接退出
	if len(proles) == 0 {
		return
	}
	// 遍历role_pid0开始到，获取到role_id
	for _, item := range proles {

		if pname != "" {
			*m = append(*m, &RoleRel{pname, item.RoleName})
		}
		// 递归
		GetRoles(item.RoleId, m, item.RoleName)
	}

}

//models包中的User
func GetUserRoles() (users []*models.Users) {
	Gorm.Select("a.user_name,c.role_name").Table("users a,user_roles b,roles c").Where("a.user_id=b.user_id and b.role_id=c.role_id").Order("a.user_id desc").Find(&users)
	return
}

//获取路由和角色对应关系
func GetRouterRoles() (routers []*models.Routers) {
	Gorm.Select("a.r_uri,a.r_method,c.role_name").
		Table("routers a,router_roles b,roles c ").
		Where(" a.r_id=b.router_id and b.role_id=c.role_id").
		Order(" role_name").Find(&routers)
	return
}

```

其中表的结构如下

![image-20220523112242254](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205231256305.png)

添加路由方法

```go
package lib

import (
   "github.com/casbin/casbin/v2"
   "github.com/casbin/gorm-adapter/v3"
   "log"
)

var E *casbin.Enforcer

func init() {
   initDB()
   adapter, err := gormadapter.NewAdapterByDB(Gorm)
   if err != nil {
      log.Fatal()
   }
   e, err := casbin.NewEnforcer("resources/model.conf", adapter)
   if err != nil {
      log.Fatal()
   }
   err = e.LoadPolicy()
   if err != nil {
      log.Fatal()
   }
   E = e
   initPolicy()
}

//从我们的库里初始化 策略数据
func initPolicy() {

   m := make([]*RoleRel, 0)
   GetRoles(0, &m, "") //获取角色对应的权限
   for _, r := range m {
      _, err := E.AddRoleForUser(r.PRole, r.Role) //添加角色
      if err != nil {
         log.Fatal(err)
      }
   }
   userRole := GetUserRoles()
   for _, ur := range userRole {
      _, err := E.AddRoleForUser(ur.UserName, ur.RoleName) //添加角色
      if err != nil {
         log.Fatal(err)
      }
   }
   ///// 初始化 路由角色
   routerRoles := GetRouterRoles()
   for _, rr := range routerRoles {
      _, err := E.AddPolicy(rr.RoleName, rr.RouterUri, rr.RouterMethod)
      if err != nil {
         log.Fatal(err)
      }
   }
}
```



添加路由的结构体

```go
package models

import "fmt"

type Routers struct {
	RouterId     int    `gorm:"column:user_id;primaryKey"`
	RouterName   string `gorm:"column:r_name"`
	RouterUri    string `gorm:"column:r_uri;"`
	RouterMethod string `gorm:"column:r_method"`
	RoleName     string
}

func (this *Routers) TableName() string {
	return "roles"
}
func (this *Routers) String() string {
	return fmt.Sprintf("%s-%s", this.RouterName, this.RoleName)
}

```



角色

```go
package models

import "fmt"

// 创建接收角色的结构体
type Role struct {
	RoleId      int    `gorm:"column:role_id;primaryKey"`
	RoleName    string `gorm:"column:role_name"`
	RolePid     int    `gorm:"column:role_pid;"`
	RoleComment string `gorm:"column:role_comment"`
}

func (this *Role) TableName() string {
	return "roles"
}
func (this *Role) String() string {
	return fmt.Sprintf("ID:%d 角色名:%s", this.RoleId, this.RoleName)
}

```

用户

```go
package models

import "fmt"

type Users struct {
	UserID   int    `gorm:"column:user_id;primaryKey"`
	UserName string `gorm:"user_name"`
	RoleName string
}

func (this *Users) TableName() string {
	return "users"
}
func (this *Users) String() string {
	return fmt.Sprintf("%s-%s", this.UserName, this.RoleName)
}

```

对`gin`的引用

```go
package main

import (
	"casbin/lib"
	"github.com/gin-gonic/gin"
)

func main() {

	r := gin.New()
	r.Use(lib.Middlewares()...)
	r.GET("/depts", func(context *gin.Context) {
		context.JSON(200, gin.H{"result": "部门列表"})
	})
	r.GET("/depts/:id", func(context *gin.Context) {
		context.JSON(200, gin.H{"result": "部门详细"})
	})
	r.POST("/depts", func(context *gin.Context) {
		context.JSON(200, gin.H{"result": "批量修改部门列表"})
	})
	r.Run(":80")

}

```

测试结果

![image-20220523124741876](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205231257905.png)



![image-20220523124805976](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205231257706.png)

## 9、对策略的自定义

### 9.1、引入正则匹配

依赖于8步骤的改动

```go
package lib

import (
	"github.com/casbin/casbin/v2"
	"github.com/casbin/gorm-adapter/v3"
	"log"
)

var E *casbin.Enforcer

func init() {
	initDB()
	adapter, err := gormadapter.NewAdapterByDB(Gorm)
	if err != nil {
		log.Fatal()
	}
	e, err := casbin.NewEnforcer("resources/model.conf", adapter)
	if err != nil {
		log.Fatal()
	}
	err = e.LoadPolicy()
	if err != nil {
		log.Fatal()
	}
	E = e
	initPolicy()
}


func initPolicy() {
    // 跳过初始化进行测试
	return

	m := make([]*RoleRel, 0)
	GetRoles(0, &m, "") //获取角色对应的权限
	for _, r := range m {
		_, err := E.AddRoleForUser(r.PRole, r.Role) //添加角色
		if err != nil {
			log.Fatal(err)
		}
	}
	userRole := GetUserRoles()
	for _, ur := range userRole {
		_, err := E.AddRoleForUser(ur.UserName, ur.RoleName) //添加角色
		if err != nil {
			log.Fatal(err)
		}
	}

	routerRoles := GetRouterRoles()
	for _, rr := range routerRoles {
		_, err := E.AddPolicy(rr.RoleName, rr.RouterUri, rr.RouterMethod)
		if err != nil {
			log.Fatal(err)
		}
	}
}

```



![image-20220523143754363](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205231437693.png)



修改成为正则匹配规则

```
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) &&  keyMatch2(r.obj,p.obj) && regexMatch(r.act,p.act)


```

测试结果

![image-20220523144504714](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205231445090.png)

### 9.2、自定义匹配函数

依赖于9.1步骤的改动

改动为以空格分隔的多个url动作

![image-20220523152341445](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205231523604.png)



修改为自定义的参数`methodmath(r.act,p.act)`

```
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) &&  keyMatch2(r.obj,p.obj) && methodmath(r.act,p.act)


```



```go
package lib

import (
	"fmt"
	"strings"
)

func init() {
    //模型当中调用的
	E.AddFunction("methodmath", func(arguments ...interface{}) (interface{}, error) {
		if len(arguments) == 2 {
			k1, k2 := arguments[0].(string), arguments[1].(string)
			MethodMath(k1, k2)
		}
		return nil, fmt.Errorf("methodmath error")
	})
}

func MethodMath(key1 string, key2 string) bool {
	ks := strings.Split(key2, "")
	for _, s := range ks {
		if s == key1 {
			return true
		}
	}
	return false
}

```

## 10、多租户的表的设计

新增租户表

```mysql
/*
 Navicat Premium Data Transfer

 Source Server         : mysql57
 Source Server Type    : MySQL
 Source Server Version : 50721
 Source Host           : localhost:3307
 Source Schema         : mytest

 Target Server Type    : MySQL
 Target Server Version : 50721
 File Encoding         : 65001

 Date: 14/10/2020 13:38:30
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for roles
-- ----------------------------
DROP TABLE IF EXISTS `roles`;
CREATE TABLE `roles`  (
  `role_id` int(11) NOT NULL AUTO_INCREMENT,
  `role_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `role_pid` int(11) NULL DEFAULT 0,
  `role_comment` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `tenant_id` int(11) NULL DEFAULT 0,
  PRIMARY KEY (`role_id`) USING BTREE,
  INDEX `TenantId`(`tenant_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of roles
-- ----------------------------
INSERT INTO `roles` VALUES (2, 'deptadmin', 0, '部门管理员', 1);
INSERT INTO `roles` VALUES (3, 'deptselecter', 7, '部门查询员', 1);
INSERT INTO `roles` VALUES (7, 'deptupdater', 2, '部门编辑员', 1);
INSERT INTO `roles` VALUES (8, 'deptadmin', 0, '部门管理员', 2);
INSERT INTO `roles` VALUES (9, 'deptselecter', 10, '部门查询员', 2);
INSERT INTO `roles` VALUES (10, 'deptupdater', 8, '部门编辑员', 2);

-- ----------------------------
-- Table structure for router_roles
-- ----------------------------
DROP TABLE IF EXISTS `router_roles`;
CREATE TABLE `router_roles`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `router_id` int(11) NULL DEFAULT NULL,
  `role_id` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `router_id`(`router_id`, `role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of router_roles
-- ----------------------------
INSERT INTO `router_roles` VALUES (13, 1, 3);
INSERT INTO `router_roles` VALUES (15, 1, 9);
INSERT INTO `router_roles` VALUES (14, 3, 7);
INSERT INTO `router_roles` VALUES (16, 3, 10);

-- ----------------------------
-- Table structure for routers
-- ----------------------------
DROP TABLE IF EXISTS `routers`;
CREATE TABLE `routers`  (
  `r_id` int(11) NOT NULL AUTO_INCREMENT,
  `r_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `r_uri` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `r_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `r_status` tinyint(4) NULL DEFAULT NULL,
  PRIMARY KEY (`r_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of routers
-- ----------------------------
INSERT INTO `routers` VALUES (1, '部门列表', '/depts', 'GET', 1);
INSERT INTO `routers` VALUES (3, '新增部门', '/depts', 'POST', 1);

-- ----------------------------
-- Table structure for tenants
-- ----------------------------
DROP TABLE IF EXISTS `tenants`;
CREATE TABLE `tenants`  (
  `tenant_id` int(11) NOT NULL AUTO_INCREMENT,
  `tenant_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  PRIMARY KEY (`tenant_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tenants
-- ----------------------------
INSERT INTO `tenants` VALUES (1, 'domain1');
INSERT INTO `tenants` VALUES (2, 'domain2');

-- ----------------------------
-- Table structure for user_roles
-- ----------------------------
DROP TABLE IF EXISTS `user_roles`;
CREATE TABLE `user_roles`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `role_id` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `user_id`(`user_id`, `role_id`) USING BTREE,
  INDEX `role_id`(`role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_roles
-- ----------------------------
INSERT INTO `user_roles` VALUES (1, 1, 3);
INSERT INTO `user_roles` VALUES (2, 2, 10);

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users`  (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,
  `tenant_id` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`user_id`) USING BTREE,
  INDEX `tenant_id`(`tenant_id`) USING BTREE,
  CONSTRAINT `users_ibfk_1` FOREIGN KEY (`tenant_id`) REFERENCES `tenants` (`tenant_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of users
-- ----------------------------
INSERT INTO `users` VALUES (1, 'xiongmao', 1);
INSERT INTO `users` VALUES (2, 'lisi', 2);

SET FOREIGN_KEY_CHECKS = 1;

```



数据库的初始化

```go
package lib

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"os"
)

var Gorm *gorm.DB

func initDB() {
	Gorm = gormDB()
}
func gormDB() *gorm.DB {
	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
		logger.Config{
			LogLevel: logger.Info, // Log level
			Colorful: false,       // 禁用彩色打印
		},
	)
	dsn := "root:123456@tcp(10.165.25.24:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err != nil {
		log.Fatal(err)
	}
	mysqlDB, err := db.DB()
	if err != nil {
		log.Fatal(err)
	}

	mysqlDB.SetMaxIdleConns(5)
	mysqlDB.SetMaxOpenConns(10)
	return db
}

```

角色表新增`TenantName`

```go
package models

import "fmt"

type Role struct {
	RoleId int  `gorm:"column:role_id;primaryKey"`
	RoleName string  `gorm:"column:role_name"`
	RolePid int  `gorm:"column:role_pid;"`
	RoleComment string `gorm:"column:role_comment"`
	TenantId string `gorm:"column:tenant_id"`
	TenantName string   `gorm:"column:tenant_name"`

}
func(this *Role) TableName() string{
	return "roles"
}
func(this *Role) String() string{
	return fmt.Sprintf("ID:%d-角色名:%s-租户名:%s",this.RoleId,this.RoleName,this.TenantName)
}

```

路由表添加`Domain`

```go
package models

import "fmt"

type Routers struct {
	RouterId int `gorm:"column:user_id;primaryKey"`
	RouterName string `gorm:"column:r_name"`
	RouterUri string `gorm:"column:r_uri;"`
	RouterMethod string `gorm:"column:r_method"`
	RoleName string
	Domain string `gorm:"column:tenant_name"`
}

func(this *Routers) TableName() string{
	return "roles"
}
func(this *Routers) String() string{
	return fmt.Sprintf("%s-%s",this.RouterName,this.RoleName)
}

```

租户添加`Domain`

```go
package models

import "fmt"

//租户模型
type Tenant struct {
	TenantId int  `gorm:"column:tenant_id;primaryKey"`
	TenantName string  `gorm:"column:tenant_name"`
}
func(this *Tenant) String() string{
	return fmt.Sprintf("%d:%s",this.TenantId,this.TenantName)
}

```

用户表的映射

```go
package models

import "fmt"

type Users struct {
	UserID int `gorm:"column:user_id;primaryKey"`
	UserName string `gorm:"column:user_name"`
	RoleName string `gorm:"column:role_name"`
	Domain string `gorm:"column:tenant_name"`

 }
func(this *Users) TableName() string{
	return "users"
}
func(this *Users) String () string{
	return fmt.Sprintf("%s-%s-%s",this.UserName,this.RoleName,this.Domain)
}

```

新增告警模型

```
[request_definition]
r = sub, dom, obj, act

[policy_definition]
p = sub, dom, obj, act

[role_definition]
g = _, _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub, r.dom) && r.dom == p.dom && keyMatch2(r.obj,p.obj) && methodMatch(r.act,p.act)

```

之后的以此类形式添加加入域实现多租户

```

p, admin,domain1, /depts, GET

p, admin,domain2, /depts, POST

g, shenyi, admin,domain1
g, lisi, admin,domain2


```



初始化权限

```go
package lib

import (
	"github.com/casbin/casbin/v2"
	"github.com/casbin/gorm-adapter/v3"
	"log"

)
var E *casbin.Enforcer
func init() {

	initDB()
	adapter,err:=gormadapter.NewAdapterByDB( Gorm)
	if err!=nil{
		log.Fatal()
	}
	e,err:= casbin.NewEnforcer("resources/model_t.conf",adapter)
	if err!=nil{
		log.Fatal()
	}
	err=e.LoadPolicy()
	if err!=nil{
		log.Fatal()
	}
	E=e
	 initPolicyWithDomain()
}
//从我们的库里初始化 策略数据  ----- 不带租户
func initPolicy()  {

	///下面 这部分是初始化 角色
	m:=make([]*RoleRel,0)
	GetRoles(0,&m,"") //获取角色 对应
	for _,r:=range m{
		_,err:=E.AddRoleForUser(r.PRole,r.Role)
		if err!=nil{
			log.Fatal(err)
		}
	}
	/////// 初始化用户角色
	userRoles:=GetUserRoles()
	for _,ur:=range userRoles{
		_,err:=E.AddRoleForUser(ur.UserName,ur.RoleName)
		if err!=nil{
			log.Fatal(err)
		}
	}
	///// 初始化 路由角色
	routerRoles:=GetRouterRoles()
	for _,rr:=range routerRoles{
		_,err:=E.AddPolicy(rr.RoleName,rr.RouterUri,rr.RouterMethod)
		if err!=nil{
			log.Fatal(err)
		}
	}



}

//租户 初始化
func initPolicyWithDomain()  {

	///下面 这部分是初始化 角色 关系
	//拼凑出这种格式
	// g, deptadmin, deptupdater,domain1
	//g, deptupdater, deptselecter,domain2
	//其中deptselecter 权限最低，然后是deptupdater ,最后是deptadmin
	roles:=GetRolesWithDomain() //获取角色 对应
	for _,r:=range roles{
		_,err:=E.AddRoleForUserInDomain(r.PRole,r.Role,r.Domain) //看这一句，加了domain参数
		if err!=nil{
			log.Fatal(err)
		}
	}
	/////// 初始化用户角色 ,格式和上面一样
	userRoles:=GetUserRolesWithDomain()
	for _,ur:=range userRoles{
		//这里也做了改变，增加了 domain参数
		_,err:=E.AddRoleForUserInDomain(ur.UserName,ur.RoleName,ur.Domain)
		if err!=nil{
			log.Fatal(err)
		}
	}
	///// 初始化 路由角色对应关系
	//格式 p	deptselecter	domain1	/depts	GET
	routerRoles:=GetRouterRolesWithDomain()
	for _,rr:=range routerRoles{
		_,err:=E.AddPolicy(rr.RoleName,rr.Domain,rr.RouterUri,rr.RouterMethod)
		if err!=nil{
			log.Fatal(err)
		}
	}



}
```

自定义匹配规则

```go
package lib

import (
	"fmt"
	"strings"
)

func init() {

	E.AddFunction("methodMatch", func(arguments ...interface{}) (i interface{}, e error) {
		if len(arguments) == 2 {
			k1, k2 := arguments[0].(string), arguments[1].(string)
			return MethodMatch(k1, k2), nil
		}
		return nil, fmt.Errorf("methodMatch error")
	})
}

// 修改自定义匹配函数
func MethodMatch(key1 string, key2 string) bool {
	ks := strings.Split(key2, " ")
	for _, s := range ks {
		if s == key1 {
			return true
		}
	}
	return false

}

```

中间件

```go
package lib

import (
	"github.com/gin-gonic/gin"
	"strings"
)

func CheckLogin() gin.HandlerFunc {
	return func(context *gin.Context) {
		if context.Request.Header.Get("token") == "" {
			context.AbortWithStatusJSON(400, gin.H{"message": "token required"})
		} else {
			context.Set("user_name", context.Request.Header.Get("token"))
			context.Next()
		}
	}
}
func RBAC() gin.HandlerFunc {
	return func(context *gin.Context) {
		user, _ := context.Get("user_name")
		// access,err:=E.Enforce(user,context.Request.RequestURI,context.Request.Method)
		domain := context.Param("domain")
		// 处理多租户带来url包含domain的问题
		uri := strings.TrimPrefix(context.Request.RequestURI, "/"+domain) //  /domain1/depts=>/depts
		access, err := E.Enforce(user, domain, uri, context.Request.Method)
		if err != nil || !access {
			context.AbortWithStatusJSON(403, gin.H{"message": "forbidden"})
		} else {
			context.Next()
		}
	}
}
func Middlewares() (fs []gin.HandlerFunc) {
	fs = append(fs, CheckLogin(), RBAC())
	return
}

```

RBAC的初始化

```go
package lib

import (
	"gcasbin/models"
	"log"
)
type RoleRel struct {
	PRole string
	Role string
	Domain string  //租户的域
}
func(this *RoleRel) String() string{
	return this.PRole+":"+this.Role+":"+this.Domain
}
func AllTenants() (ret []*models.Tenant){  //获取所有租户
	db:=Gorm.Find(&ret)
	if db.Error!=nil{
		log.Fatal(db)
	}
	return
}
//获取角色---不带租户
func GetRoles(pid int,m *[]*RoleRel,pname string)   {
	proles:=make([]*models.Role,0)
	Gorm.Where("role_pid=?",pid).Find(&proles)
	if len(proles)==0{
		return
	}
	for _,item:=range proles{
		if pname!=""{
			*m=append(*m,&RoleRel{pname,item.RoleName,""})
		}
		GetRoles(item.RoleId,m,item.RoleName)
	}

}
//获取角色---带租户
func GetRolesWithDomain() []*RoleRel{
	ts:=AllTenants() //获取 所有 租户
	roleRels:=make([]*RoleRel,0)
	for _,t:=range ts{ //遍历租户
		 t_roleRels:=make([]*RoleRel,0)
		 getRolesWithDomain(0,&t_roleRels,"",t)
		 roleRels=append(roleRels,t_roleRels...)
	}
	return roleRels
}
func getRolesWithDomain(pid int,m *[]*RoleRel,pname string,t *models.Tenant )   {
	proles:=make([]*models.Role,0)
	//注意这里，根据每个租户ID进行获取
	Gorm.Where("role_pid=? and tenant_id=?",pid,t.TenantId).Find(&proles)
	if len(proles)==0{
		return
	}
	for _,item:=range proles{
		if pname!=""{
			*m=append(*m,&RoleRel{pname,item.RoleName,t.TenantName})
		}
		getRolesWithDomain(item.RoleId,m,item.RoleName,t)
	}

}
//获取用户和角色对应关系
func GetUserRoles() (users []*models.Users){
	Gorm.Select("a.user_name,c.role_name ").Table("users a,user_roles b ,roles c ").
		Where("a.user_id=b.user_id and b.role_id=c.role_id").
		Order("a.user_id desc").Find(&users)
	return
}
func GetUserRolesWithDomain() (users []*models.Users){
	Gorm.Select("a.user_name,c.role_name,d.tenant_name ").Table(" users a,user_roles b ,roles c,tenants d ").
		Where(" a.user_id=b.user_id and b.role_id=c.role_id and c.tenant_id=d.tenant_id ").
		Order("a.user_id desc").Find(&users)
	return
}

//获取路由和角色对应关系
func GetRouterRoles() (routers []*models.Routers){
	Gorm.Select("a.r_uri,a.r_method,c.role_name").
		Table("routers a,router_roles b,roles c ").
		Where(" a.r_id=b.router_id and b.role_id=c.role_id").
		Order(" role_name").Find(&routers)
	return
}
//带 租户的 路由角色获取
func GetRouterRolesWithDomain() (routers []*models.Routers){
	Gorm.Select(" a.r_uri,a.r_method,c.role_name,d.tenant_name ").
		Table("routers a,router_roles b,roles c ,tenants d   ").
		Where(" a.r_id=b.router_id and b.role_id=c.role_id and c.tenant_id=d.tenant_id").
		Order(" role_name").Find(&routers)
	return
}
```



![image-20220524165300494](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205241731416.png)





![image-20220524173044459](https://cdn.jsdelivr.net/gh/lzq70112/images/blog/202205241730613.png)



```go
package main

import (
	"gcasbin/lib"
	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.New()
	r.Use(lib.Middlewares()...)
	r.GET("/:domain/depts", func(context *gin.Context) {
		context.JSON(200, gin.H{"result": "部门列表--" + context.Param("domain")})
	})

	r.POST("/:domain/depts", func(context *gin.Context) {
		context.JSON(200, gin.H{"result": "批量修改部门列表" + context.Param("domain")})
	})

	r.Run(":80")

}

```

## 11、超级管理设置的三种方法

1、在中间件中写死

2、修改配置文件

3、写自定义函数

其他依赖步骤10

修改数据模型

```
[request_definition]
r = sub, dom, obj, act

[policy_definition]
p = sub, dom, obj, act

[role_definition]
g = _, _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub, r.dom) && r.dom == p.dom && keyMatch2(r.obj,p.obj) && methodMatch(r.act,p.act) || supermatch(r.sub)

```

自定义函数

```go
package lib

import (
	"fmt"
	"strings"
)

var ADMINS = []string{"admin", "root"}

func init() {

	E.AddFunction("methodMatch", func(arguments ...interface{}) (i interface{}, e error) {
		if len(arguments) == 2 {
			k1, k2 := arguments[0].(string), arguments[1].(string)
			return MethodMatch(k1, k2), nil
		}
		return nil, fmt.Errorf("methodMatch error")
	})
	E.AddFunction("supermatch", func(arguments ...interface{}) (i interface{}, e error) {
		if len(arguments) == 1 {
			users := arguments[0].(string)
			return IsSuperAdmin(users), nil
		}
		return nil, fmt.Errorf("supermatch error")
	})
}

// 添加超级管理员函数
func IsSuperAdmin(userName string) bool {
	for _, user := range ADMINS {
		if user == userName {
			return true
		}
	}
	return false
}

// 修改自定义匹配函数
func MethodMatch(key1 string, key2 string) bool {
	ks := strings.Split(key2, " ")
	for _, s := range ks {
		if s == key1 {
			return true
		}
	}
	return false

}

```

## 12、策略生效范围

当我们想实现用户某一个动作的执行限制时

```
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act, eft

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))


[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act

```

说明

```
[policy_definition]
p = sub, obj, act, eft
添加策略动作

[policy_effect]
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))
必须有一条allow通过 并且任何一条为deny的策略
```

此时用户为`xiongmao`的会被驳回

```

p, role1, /depts, GET, allow
p, role1, /depts, POST, allow
p, role1, /depts, DELETE, allow
p, xiongmao, /depts, POST, deny

g, xiongmao, role1
g, lisi, role1


```

```go
package main

import (
	"github.com/casbin/casbin/v2"
	"log"
)

func main() {


	e,_:= casbin.NewEnforcer("resources/model.conf","resources/p.csv")

	ok,err:= e.Enforce("xiongmao", "/depts", "POST")
	if err==nil && ok {
		log.Println("xiongmao,运行通过")
	}
	ok,err= e.Enforce("lisi", "/depts", "POST")
	if err==nil && ok {
		log.Println("lisi,运行通过")
	}


}
```

